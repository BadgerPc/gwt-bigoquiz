<?xml version="1.0" encoding="UTF-8"?>
<quiz xmlns="http://bigoquiz.com/document" format_version="1" id="algorithms">
    <title>Algorithms</title>
    <section id="algorithms-sort-advantages" answers_as_choices="true">
        <title>Advantages of Sorting Algorithms</title>

        <question id="algorithms-sort-advantages-quicksort">
            <text>Quicksort</text>
            <link>https://en.wikipedia.org/wiki/Quicksort</link>
            <answer>In-place (O(log(n)) space). Data Locality. Small coefficient of O(n log(n)).</answer>
        </question>
        <question id="algorithms-sort-advantages-mergesort">
            <text>Mergesort</text>
            <link>https://en.wikipedia.org/wiki/Merge_sort</link>
            <answer>O(n log(n)) worst case time. Stable. Data Locality. Parallelizable. Can be External.</answer>
        </question>
        <question id="algorithms-sort-advantages-heapsort">
            <text>Heapsort</text>
            <link>https://en.wikipedia.org/wiki/Heapsort</link>
            <answer>O(n log(n)) worst case time. O(1) space.</answer>
        </question>
        <question id="algorithms-sort-advantages-timsort">
            <text>Timsort</text>
            <link>https://en.wikipedia.org/wiki/Timsort</link>
            <answer>O(n) best case time.</answer>
        </question>
        <question id="algorithms-sort-advantages-insertion-sort">
            <text>Insertion Sort</text>
            <answer>Fast for small n, even though it has O(n^2) average time. Fast for nearly-sorted items.</answer>
        </question>
        <question id="algorithms-sort-advantages-selection-sort">
            <text>Selection Sort</text>
            <answer>Minimal swaps.</answer>
        </question>
        <!-- None?
        <question id="algorithms-sort-advantages-shell-sort">
            <text>Shell Sort</text>
            <answer></answer>
        </question>
        -->
        <!-- TODO: Don't use when range m is much greater than n: -->
        <question id="algorithms-sort-advantages-counting-sort">
            <text>Counting Sort</text>
            <link>https://en.wikipedia.org/wiki/Counting_sort</link>
            <answer>O(n) time, but with O(m) space</answer>
        </question>
        <question id="algorithms-sort-advantages-radix-sort">
            <text>Radix Sort</text>
            <link>https://en.wikipedia.org/wiki/Radix_sort</link>
            <answer>O(n) time. Minimal space.</answer>
        </question>
        <question id="algorithms-sort-advantages-bucket-sort">
            <text>Bucket Sort</text>
            <link>https://en.wikipedia.org/wiki/Bucket_sort</link>
            <answer>Like Counting Sort, but uses O(n) space instead of O(m) space,</answer>
        </question>
        <!-- None?
        <question id="algorithms-sort-advantages-bubble-sort">
            <text>Bubble Sort</text>
            <answer></answer>
        </question>
        -->
    </section>

    <!-- What do they need space for? -->

    <section id="algorithms-sort-stability" answers_as_choices="true">
        <title>Sort Stability</title>
        <link>https://en.wikipedia.org/wiki/Stable_sort</link>

        <question id="algorithms-sort-stability-quicksort">
            <text>Quicksort</text>
            <link>https://en.wikipedia.org/wiki/Quicksort</link>
            <answer>Unstable</answer>
        </question>
        <question id="algorithms-sort-stability-mergesort">
            <text>Mergesort</text>
            <link>https://en.wikipedia.org/wiki/Merge_sort</link>
            <answer>Stable</answer>
        </question>
        <question id="algorithms-sort-stability-heapsort">
            <text>Heapsort</text>
            <link>https://en.wikipedia.org/wiki/Heapsort</link>
            <answer>Unstable</answer>
        </question>
        <question id="algorithms-sort-stability-timsort">
            <text>Timsort</text>
            <link>https://en.wikipedia.org/wiki/Timsort</link>
            <answer>Stable</answer>
        </question>
        <question id="algorithms-sort-stability-insertion-sort">
            <text>Insertion Sort</text>
            <link>https://en.wikipedia.org/wiki/Insertion_sort</link>
            <answer>Stable</answer>
        </question>
        <question id="algorithms-sort-stability-selection-sort">
            <text>Selection Sort</text>
            <link>https://en.wikipedia.org/wiki/Selection_sort</link>
            <answer>Unstable</answer>
        </question>
        <question id="algorithms-sort-stability-shellsort">
            <text>Shellsort</text>
            <link>https://en.wikipedia.org/wiki/Shellsort</link>
            <answer>Unstable</answer>
        </question>
        <question id="algorithms-sort-stability-counting-sort">
            <text>Counting Sort</text>
            <answer>Stable</answer>
        </question>
        <question id="algorithms-sort-stability-radix-sort">
            <text>Radix Sort</text>
            <link>https://en.wikipedia.org/wiki/Radix_sort</link>
            <answer>Stable</answer>
        </question>
        <question id="algorithms-sort-stability-bucket-sort">
            <text>Bucket Sort</text>
            <answer>Stable</answer>
        </question>
        <question id="algorithms-sort-stability-bubble-sort">
            <text>Bubble Sort</text>
            <answer>Stable</answer>
        </question>
    </section>

    <section id="algorithms-inplace" answers_as_choices="true">
        <title>Sorting Algorithms: In Place or Not</title>
        <link>https://en.wikipedia.org/wiki/In-place_algorithm</link>

        <question id="algorithms-inplace-quicksort">
            <text>Quicksort</text>
            <link>https://en.wikipedia.org/wiki/Quicksort</link>
            <answer>In-place (but small additional space needed)</answer>
        </question>
        <question id="algorithms-inplace-mergesort">
            <text>Mergesort</text>
            <link>https://en.wikipedia.org/wiki/Merge_sort</link>
            <answer>Not in-place</answer>
        </question>
        <question id="algorithms-inplace-heapsort">
            <text>Heapsort</text>
            <link>https://en.wikipedia.org/wiki/Heapsort</link>
            <answer>In-place</answer>
        </question>
        <question id="algorithms-inplace-timsort">
            <text>Timsort</text>
            <link>https://en.wikipedia.org/wiki/Timsort</link>
            <answer>Not in-place</answer>
        </question>
        <question id="algorithms-inplace-insertion-sort">
            <text>Insertion Sort</text>
            <link>https://en.wikipedia.org/wiki/Insertion_sort</link>
            <answer>In-place</answer>
        </question>
        <question id="algorithms-inplace-selection-sort">
            <text>Selection Sort</text>
            <link>https://en.wikipedia.org/wiki/Selection_sort</link>
            <answer>In-place</answer>
        </question>
        <question id="algorithms-inplace-shellsort">
            <text>Shellsort</text>
            <link>https://en.wikipedia.org/wiki/Shellsort</link>
            <answer>In-place</answer>
        </question>
        <question id="algorithms-inplace-counting-sort">
            <text>Counting Sort</text>
            <answer>Not in-place</answer>
        </question>
        <question id="algorithms-inplace-radix-sort">
            <text>Radix Sort</text>
            <link>https://en.wikipedia.org/wiki/Radix_sort</link>
            <answer>Not in-place</answer>
        </question>
        <question id="algorithms-inplace-bucket-sort">
            <text>Bucket Sort</text>
            <answer>Not in-place</answer>
        </question>
        <question id="algorithms-inplace-bubble-sort">
            <text>Bubble Sort</text>
            <answer>In-place</answer>
        </question>
    </section>

    <section id="algorithms-sort-comparison" answers_as_choices="true">
        <title>Sorting Algorithms: Comparison or Non-Comparison</title>
        <link>https://en.wikipedia.org/wiki/Comparison_sort</link>

        <question id="algorithms-sort-comparison-quicksort">
            <text>Quicksort</text>
            <link>https://en.wikipedia.org/wiki/Quicksort</link>
            <answer>Comparison</answer>
        </question>
        <question id="algorithms-sort-comparison-mergesort">
            <text>Mergesort</text>
            <link>https://en.wikipedia.org/wiki/Merge_sort</link>
            <answer>Comparison</answer>
        </question>
        <question id="algorithms-sort-comparison-heapsort">
            <text>Heapsort</text>
            <link>https://en.wikipedia.org/wiki/Heapsort</link>
            <answer>Comparison</answer>
        </question>
        <question id="algorithms-sort-comparison-timsort">
            <text>Timsort</text>
            <link>https://en.wikipedia.org/wiki/Timsort</link>
            <answer>Comparison</answer>
        </question>
        <question id="algorithms-sort-comparison-insertion-sort">
            <text>Insertion Sort</text>
            <link>https://en.wikipedia.org/wiki/Insertion_sort</link>
            <answer>Comparison</answer>
        </question>
        <question id="algorithms-sort-comparison-selection-sort">
            <text>Selection Sort</text>
            <link>https://en.wikipedia.org/wiki/Selection_sort</link>
            <answer>Comparison</answer>
        </question>
        <question id="algorithms-sort-comparison-shellsort">
            <text>Shellsort</text>
            <link>https://en.wikipedia.org/wiki/Shellsort</link>
            <answer>Comparison</answer>
        </question>
        <question id="algorithms-sort-comparison-counting-sort">
            <text>Counting Sort</text>
            <answer>Non-Comparison</answer>
        </question>
        <question id="algorithms-sort-comparison-radix-sort">
            <text>Radix Sort</text>
            <link>https://en.wikipedia.org/wiki/Radix_sort</link>
            <answer>Non-Comparison</answer>
        </question>
        <question id="algorithms-sort-comparison-bucket-sort">
            <text>Bucket Sort</text>
            <answer>Comparison</answer>
        </question>
        <question id="algorithms-sort-comparison-bubble-sort">
            <text>Bubble Sort</text>
            <answer>Comparison</answer>
        </question>
    </section>


    <section id="algorithms-sort-description" answers_as_choices="true" and_reverse="true">
        <title>Sorting Algorithm Description</title>

        <question id="algorithms-sort-description-quicksort">
            <text>Quicksort</text>
            <link>https://en.wikipedia.org/wiki/Quicksort</link>
            <answer>Find partition and recurse.</answer>
        </question>
        <question id="algorithms-sort-description-mergesort">
            <text>Mergesort</text>
            <link>https://en.wikipedia.org/wiki/Merge_sort</link>
            <answer>Divide, sort, merge, recurse.</answer>
        </question>
        <question id="algorithms-sort-description-heapsort">
            <text>Heapsort</text>
            <link>https://en.wikipedia.org/wiki/Heapsort</link>
            <answer>Like Selection Sort, but first heapifies the array and then chooses the largest values.</answer>
        </question>
        <question id="algorithms-sort-description-timsort">
            <text>Timsort</text>
            <link>https://en.wikipedia.org/wiki/Timsort</link>
            <answer>Hybrid of Mergesort and Insertion Sort. Finds ordered subsequences.</answer>
        </question>
        <question id="algorithms-sort-description-insertion-sort">
            <text>Insertion Sort</text>
            <link>https://en.wikipedia.org/wiki/Insertion_sort</link>
            <answer>Move each item, by neighbour swaps, to its location in the sorted list. Like sorting a hand of cards.</answer>
        </question>
        <question id="algorithms-sort-description-selection-sort">
            <text>Selection Sort</text>
            <link>https://en.wikipedia.org/wiki/Selection_sort</link>
            <answer>Repeatedly finds smallest item and moves it to the end of the sorted section at the start.</answer>
        </question>
        <question id="algorithms-sort-description-shell-sort">
            <text>Shellsort</text>
            <link>https://en.wikipedia.org/wiki/Shellsort</link>
            <answer>Like Insertion Sort, but considering every hth element, then again for lower h, until h is 1.</answer>
        </question>
        <question id="algorithms-sort-description-counting-sort">
            <text>Counting Sort</text>
            <answer>Count how often each value appears. Calculate the start index for each value. Copy each value to the start index in the output, decrementing the start index each time for each value.</answer>
        </question>
        <question id="algorithms-sort-description-radix-sort">
            <text>Radix Sort</text>
            <link>https://en.wikipedia.org/wiki/Radix_sort</link>
            <answer>Sort d times, each time examining just b bits, using counting sort or bucket sort.</answer>
        </question>
        <question id="algorithms-sort-description-bucket-sort">
            <text>Bucket Sort</text>
            <answer>Scatter items into buckets for ranges. Sort each bucket. Fill the array from the sorted buckets.</answer>
        </question>
        <question id="algorithms-sort-description-bubble-sort">
            <text>Bubble Sort</text>
            <answer>Compare and swap pairs until no more swaps are necessary.</answer>
        </question>

        <!-- TODO? Burstsort (uses a Trie) https://en.wikipedia.org/wiki/Burstsort -->
    </section>

    <!-- Greedy Algorithms: Dijkstra's, Scheduling, Make change (canonical coins).
      Huffman Codes: Bottom-up. Merge items with least frequency, giving the subtree the sum of their frequencies. Repeat.  -->
    <!--   Scheduling jobs: Length and weight. Completion Time.  Minimise W*C. So sort by -->
    <!--   Scheduling to avoid conflicts: Choose earliest finish time first. -->

    <!-- Divide and Conquer Algorithms:
    https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms
    Quicksort, Mergesort, Hashing?, Convex Hull (Divide & Conquer), Strassen Matrix Multiplication,
    median finding (quickselect, or (better) median of medians),
    polynomial multiplication, FFT  -->

    <!-- Dynamic Programming Algorithms:
      Interval/Job Scheduling with weights:
        opt(R) = max 1 <= i <= n (wi + opt(Rfinish(i)))
        O(n^2) but apparently O(nlog(n)) is possible.
        Add the requirement that not all jobs can be done on the same machine (or by same person), then it is NP-complete.
      Bellmann-Ford
      Floyd Warshall,
      Make change (non-canonical coins),
      String Comparison.
      Building an optimal binary search tree: https://en.wikipedia.org/wiki/Optimal_binary_search_tree#Knuth.27s_dynamic_programming_algorithm
        (though Huffmann codes can be done with greedy algorithm.)
      Independent Set of a Path Graph (in Stanford/Coursera course, part 2): https://www.coursera.org/learn/algorithm-design-analysis-2/lecture/TZgJM/wis-in-path-graphs-a-reconstruction-algorithm
        1 Dimension. (O(n)):
          A[i] = max(A[i-1], A[i-2] + w)
      Independent Set of a Tree Graph (in Stanford/Coursera course, part 2, quiz 3)
        "Recall our dynamic programming algorithm for computing the maximum-weight independent set of a path graph. Consider the following proposed extension to more general graphs. Consider an undirected graph with positive vertex weights. For a vertex v, obtain the graph G′(v) by deleting v and its incident edges from G, and obtain the graph G″(v) from G by deleting v, its neighbors, and all of the corresponding incident edges from G. Let OPT(H) denote the value of a maximum-weight independent set of a graph H. Consider the formula OPT(G)=max{OPT(G′(v)),wv+OPT(G″(v))}, where v is an arbitrary vertex of G of weight wv"
      Sequence Alignment for Needleman-Wunsch score: https://www.coursera.org/learn/algorithm-design-analysis-2/lecture/QJkyp/optimal-substructure
        Score, with cost for gaps in either string. 3 cases: No gap, gap in X, or gap in Y. 2 Dimensions.
          A[i, j] = min(A[i-1, j-1], A[i-1, j] + gap_cost, A[i, j-1] + gap_cost) -->

    <!-- Convex hull
    Median Finding -->

    <!-- Online algorithms -->

    <!-- Strings and sets:
      Set Cover:
      Set Packing:
      String Matching:
      Approximate string matching:
        DP with costs for substitution, insertion, and deletion.
          Longest common subsequence is string distance DP algorithm without substitution.
          Longest increasing subsequence?
        Bit-parallel algorithm (page 633 of TADM).
      Longest Common Subsequence:
        Difference to Longest Common Substring
      Shortest Common Substring

    -->

    <!-- Postfix notation evaluation: Push operands on to stack. When we see an operator, we pop 2 items, apply, and push back.
         (We don't need to care about operator precedence. -->
    <!-- Proofs:
    Job/Interval Scheduling: Exchange argument: Order edge in order of duration / finish time.
    Kruskal's MST: Exchange Argument: Order edges in order of increasing cost. TODO-->

    <!-- Ukkonen's algorithm for Suffix Tree Construction:
         https://en.wikipedia.org/wiki/Ukkonen%27s_algorithm
         an "online algorithm" -->

</quiz>