<?xml version="1.0" encoding="UTF-8"?>
<quiz xmlns="http://bigoquiz.com/document" format_version="1" id="datastructures">
    <title>Data Structures</title>
    <section id="datastructures-abstract-data-types" answers_as_choices="true">
        <title>Abstract Data Types</title>
        <link>https://en.wikipedia.org/wiki/Abstract_data_type</link>

        <question id="datastructures-abstract-list">
            <text>Container</text>
            <link>https://en.wikipedia.org/wiki/Container_(abstract_data_type)</link>
            <answer>Abstract data type with a collection of objects.</answer>
        </question>

        <question id="datastructures-abstract-list">
            <text>List</text>
            <link>https://en.wikipedia.org/wiki/List_(abstract_data_type)</link>
            <answer>Abstract data type with an ordered sequence of values.</answer>
        </question>

        <question id="datastructures-abstract-set">
            <text>Set</text>
            <link>https://en.wikipedia.org/wiki/Set_(abstract_data_type)</link>
            <answer>Abstract data type with an unordered sequence of values without repeated values.</answer>
        </question>

        <question id="datastructures-abstract-multi set">
            <text>Multiset</text>
            <link>https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset</link>
            <answer>A set that allows repeated values or duplicates.</answer>
        </question>

        <question id="datastructures-abstract-multimap">
            <text>Map</text>
            <link>https://en.wikipedia.org/wiki/Associative_array</link>
            <answer>Abstract data type with a collection of keys and associated values.</answer>
        </question>

        <question id="datastructures-abstract-graph">
            <text>Graph</text>
            <link>https://en.wikipedia.org/wiki/Graph_(abstract_data_type)</link>
            <answer>Abstract data type with vertices and edges.</answer>
        </question>

        <question id="datastructures-abstract-stack">
            <text>Stack</text>
            <link>https://en.wikipedia.org/wiki/Stack_(abstract_data_type)</link>
            <answer>Abstract data type with push and pop in last-in-first-out (LIFO) order.</answer>
        </question>

        <question id="datastructures-abstract-queue">
            <text>Queue</text>
            <link>https://en.wikipedia.org/wiki/Queue_(abstract_data_type)</link>
            <answer>Abstract data type with push and pop in first-in-first-out (FIFO) order.</answer>
        </question>

        <question id="datastructures-abstract-priority-queue">
            <text>Priority Queue</text>
            <link>https://en.wikipedia.org/wiki/Heap_(data_structure)</link>
            <answer>Abstract data type that allows fast min (or max) retrieval. Usually implemented with a heap.</answer>
            <!-- Advantages of different implementations, including binary heap, binomial heap (easy merging), Fibonacci Heap (certain performance?), etc -->
            <!-- See https://en.wikipedia.org/wiki/Binomial_heap#Summary_of_running_times -->
        </question>

        <question id="datastructures-abstract-double-ended-queue">
            <text>Double-Ended Queue (Dequeue, Deque)</text>
            <link>https://en.wikipedia.org/wiki/Double-ended_queue</link>
            <answer>A queue allowing addition or removal from either end.</answer>
        </question>

        <question id="datastructures-abstract-double-ended-priority-queue">
            <text>Double-Ended Priority Queue (DEPQ)</text>
            <link>https://en.wikipedia.org/wiki/Double-ended_priority_queue</link>
            <answer>A priority queue allowing removal of both the min and max.</answer>
        </question>
    </section>

    <section id="datastructures-description" answers_as_choices="true">
        <title>Descriptions of Data Structures</title>

        <subsection id="datastructures-description-trees">
            <title>Trees</title>

            <question id="datastructures-description-tree">
                <text>Tree</text>
                <link>https://en.wikipedia.org/wiki/Tree_(data_structure)</link>
                <answer>Allows traversal of a tree of nodes.</answer>
            </question>

            <question id="datastructures-description-binary-search-tree">
                <text>Binary Search Tree</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree</link>
                <answer>A tree whose child nodes are in sorted order, allowing binary search of the whole tree.</answer>
            </question>

            <question id="datastructures-description-self-balancing-binary-search-tree">
                <text>Self-Balancing Binary Search Tree (Balanced Binary Search Tree)</text>
                <link>https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree</link>
                <answer>A binary search tree that keeps its height small.</answer>
            </question>

            <question id="datastructures-description-optimal-binary-search-tree">
                <text>Optimal Binary Search Tree</text>
                <link>https://en.wikipedia.org/wiki/Optimal_binary_search_tree</link>
                <answer>A binary search tree with the smallest possible search time for certain queries.</answer>
            </question>

            <question id="datastructures-description-binary-tree">
                <text>Binary Tree</text>
                <link>https://en.wikipedia.org/wiki/Binary_tree</link>
                <answer>A tree whose nodes have no more than 2 children.</answer>
            </question>

            <question id="datastructures-description-binomial-tree">
                <text>Binomial Tree</text>
                <link>https://en.wikipedia.org/wiki/Binomial_heap#Binomial_heap</link> <!-- Update if it gets its own wiki page. -->
                <answer>A tree in which a node of order k has children who are roots of trees of order k, k-1, ... 0. So each child's tree is deeper than its sibling child's tree. Permits easy merging of trees.</answer>
            </question>

            <question id="datastructures-description-b-tree">
                <text>B-Tree</text>
                <link>https://en.wikipedia.org/wiki/Binary_tree</link>
                <answer>A self-balancing tree in which each node can have multiple keys, separating multiple child nodes.</answer>
            </question>

            <question id="datastructures-description-2-3-tree">
                <text>2-3 Tree</text>
                <link>https://en.wikipedia.org/wiki/2%E2%80%933_tree</link>
                <answer>B-Tree of order 3.</answer>
            </question>

            <question id="datastructures-description-2-3-4-tree">
                <text>2-3-4 Tree</text>
                <link>https://en.wikipedia.org/wiki/2%E2%80%933%E2%80%934_tree</link>
                <answer>B-Tree of order 4.</answer>
            </question>

            <question id="datastructures-description-avl-tree">
                <text>AVL Tree</text>
                <link>https://en.wikipedia.org/wiki/AVL_tree</link>
                <answer>A self-balancing binary search tree that, after an insert or deletion, rotates the lowest node whose child nodes' heights differ by more than 1..</answer>
            </question>

            <question id="datastructures-description-red-black-tree">
                <text>Red-Black Tree</text>
                <link>https://en.wikipedia.org/wiki/Red%E2%80%93black_tree</link>
                <answer>A self-balancing binary search tree that, after an insert or deletion, rotates the lowest nodes that do not satisfy the coloring constraints: Root is black. All leaves are black. All children of red nodes are black. All paths to leaves contains the same number of black nodes.</answer>
            </question>

            <question id="datastructures-description-cartesian-tree">
                <text>Cartesian Tree</text>
                <link>https://en.wikipedia.org/wiki/Cartesian_tree</link>
                <answer>A heap-ordered tree whose in-order traversal recreates the original sequence.</answer>
            </question>

            <question id="datastructures-description-trie">
                <text>Trie (Digital Tree, Prefix Tree)</text>
                <link>https://en.wikipedia.org/wiki/Trie</link>
                <answer>Stores all k prefixes of n strings.</answer>
            </question>

            <question id="datastructures-description-radix-tree">
                <text>Radix Tree (Radix Trie, Compact Prefix Tree, Patricia Trie)</text>
                <link>https://en.wikipedia.org/wiki/Radix_tree</link>
                <answer>Space-optimized Trie.</answer>
            </question>

            <!-- TODO: https://en.wikipedia.org/wiki/Deterministic_acyclic_finite_state_automaton -->

            <question id="datastructures-description-suffix-tree">
                <text>Suffix Tree</text>
                <link>https://en.wikipedia.org/wiki/Suffix_tree</link>
                <answer>Stores all k suffixes of n strings, allowing searches for all substrings.</answer>
            </question>

            <!-- TODO: Suffix array -->

            <question id="datastructures-description-van-emde-boas-tree">
                <text>Van Emde Boas Tree</text>
                <link>https://en.wikipedia.org/wiki/Van_Emde_Boas_tree</link>
                <answer>Associative array allowing fast O(lg lg N) successor/predecessor, and O(1) max/min, on keys of limited range N. by using a hierarchy of of clusters, each with a min and max.</answer>
            </question>

        </subsection>

        <subsection id="datastructures-description-heaps">
            <title>Heaps</title>

            <question id="datastructures-description-heap">
                <text>Heap</text>
                <link>https://en.wikipedia.org/wiki/Heap_(data_structure)</link>
                <answer>A tree-based structure whose parent nodes are less (for a min heap) or greater (for a max heap) than their children, allowing fast min (or max) retrieval.</answer>
            </question>

            <question id="datastructures-description-binary-heap">
                <text>Binary Heap</text>
                <link>https://en.wikipedia.org/wiki/Binary_heap</link>
                <answer>A heap implemented with a binary tree, which is complete (all levels are filled, apart from leaves, which are filled from left to right.)</answer>
            </question>

            <question id="datastructures-description-binomial-heap">
                <text>Binomial Heap</text>
                <link>https://en.wikipedia.org/wiki/Binomial_heap</link>
                <answer>A mergeable heap, implemented as a collection of binomial trees.</answer>
            </question>

            <question id="datastructures-description-fibonacci-heap">
                <text>Fibonacci Heap</text>
                <link>https://en.wikipedia.org/wiki/Fibonacci_heap</link>
                <answer>A heap implemented as a collection of heaps, allowing fast decrease-key, delete, and merge.</answer>
            </question>

            <question id="datastructures-description-treap">
                <text>Treap</text>
                <link>https://en.wikipedia.org/wiki/Treap</link>
                <answer>A self-balancing binary search tree that is also a min (or max) heap in terms of a random weight for each node, resulting in a random binary search tree that is likely to be balanced..</answer>
            </question>
        </subsection>

        <subsection id="datastructures-description-others">
            <title>Others</title>

            <question id="datastructures-description-bloom-filter">
                <text>Bloom Filter</text>
                <link>https://en.wikipedia.org/wiki/Bloom_filter</link>
                <answer>Tests membership, with possibility of false positives.</answer>
            </question>

            <question id="datastructures-description-union-find">
                <text>Union Find (Disjoint Set)</text>
                <link>https://en.wikipedia.org/wiki/Disjoint-set_data_structure</link>
                <answer>Groups items into subsets.</answer>
            </question>

            <question id="datastructures-description-adjacency-list">
                <text>Adjacency List</text>
                <link>https://en.wikipedia.org/wiki/Adjacency_list</link>
                <answer>Lists nodes and their incident (often only outgoing) edges.</answer>
            </question>

            <question id="datastructures-description-adjacency-matrix">
                <text>Adjacency Matrix</text>
                <link>https://en.wikipedia.org/wiki/Adjacency_matrix</link>
                <answer>For any 2 nodes, provides the edge, if any, that connects them.</answer>
            </question>

            <question id="datastructures-description-singly-linked-list">
                <text>Singly Linked List</text>
                <link>https://en.wikipedia.org/wiki/Linked_list#Singly_linked_list</link>
                <answer>Allows forward traversal of the items in the list.</answer>
            </question>

            <question id="datastructures-description-doubly-linked-list">
                <text>Doubly Linked List</text>
                <link>https://en.wikipedia.org/wiki/Doubly_linked_list</link>
                <answer>Allows forward and backward traversal of the items in the list.</answer>
            </question>

            <question id="datastructures-description-hash-table">
                <text>Hash Table</text>
                <link>https://en.wikipedia.org/wiki/Hash_table</link>
                <answer>Maps keys to values using a hash function.</answer>
            </question>

            <question id="datastructures-description-skip-list">
                <text>Skip List</text>
                <link>https://en.wikipedia.org/wiki/Skip_list</link>
                <answer>A linked hierarchy of ordered elements, starting with the sparsest subsequence.</answer>
            </question>

            <question id="datastructures-description-splay-tree">
                <text>Splay Tree</text>
                <link>https://en.wikipedia.org/wiki/Splay_tree</link>
                <answer>Binary Search Tree that optimizes itself for recently accessed elements.</answer>
            </question>

            <question id="datastructures-description-k-d-tree">
                <text>K-D Tree</text>
                <link>https://en.wikipedia.org/wiki/K-d_tree</link>
                <answer>Allows proximity search in k-dimensional data by partitioning the space.</answer>
            </question>
        </subsection>
    </section>

    <section id="datastructures-implementations" answers_as_choices="true">
        <title>Implementations of Data Structures</title>

        <subsection id="datastructures-implementations-trees">
            <title>Trees</title>

            <question id="datastructures-implementation-tree">
                <text>Tree</text>
                <link>https://en.wikipedia.org/wiki/Tree_(data_structure)</link>
                <answer>Nodes with a data field and pointers to child nodes.</answer>
            </question>

            <question id="datastructures-implementation-binary-search-tree">
                <text>Binary Search Tree</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree</link>
                <answer>Array or tree structure.</answer>
            </question>

            <question id="datastructures-implementation-self-balancing-binary-search-tree">
                <text>Self-Balancing Binary Search Tree (Balanced Binary Search Tree)</text>
                <link>https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree</link>
                <answer>Perform local rotation transformations after changes.</answer>
            </question>

            <question id="datastructures-implementation-optimal-binary-search-tree">
                <text>Optimal Binary Search Tree</text>
                <link>https://en.wikipedia.org/wiki/Optimal_binary_search_tree</link>
                <answer>Construct initially and prevent modification, using dynamic programming. Or balance optimally (theoretically) after each modification.</answer>
            </question>

            <question id="datastructures-implementation-binary-tree">
                <text>Binary Tree</text>
                <link>https://en.wikipedia.org/wiki/Binary_tree</link>
                <answer>Nodes with a data field and pointers to only 2 child nodes.</answer>
            </question>

            <question id="datastructures-implementation-binomial-tree">
                <text>Binomial Tree</text>
                <link>https://en.wikipedia.org/wiki/Binomial_heap#Binomial_heap</link> <!-- Update if it gets its own wiki page. -->
                <answer>A tree in which a node of order k has children who are roots of trees of order k, k-1, ... 0. Construct by merging trees of same order, by adding the second tree as a child of the first tree's root.</answer>
            </question>

            <question id="datastructures-implementation-b-tree">
                <text>B-Tree</text>
                <link>https://en.wikipedia.org/wiki/Binary_tree</link>
                <answer>Nodes with multiple keys separating multiple child nodes. Nodes with d keys have d+1 child nodes.</answer>
            </question>

            <question id="datastructures-implementation-2-3-tree">
                <text>2-3 Tree</text>
                <link>https://en.wikipedia.org/wiki/2%E2%80%933_tree</link>
                <answer>B-Tree of order 3. Nodes with 1 or 2 keys separating 2 or 3 child nodes, respectively.</answer>
            </question>

            <question id="datastructures-implementation-2-3-4-tree">
                <text>2-3-4 Tree</text>
                <link>https://en.wikipedia.org/wiki/2%E2%80%933%E2%80%934_tree</link>
                <answer>B-Tree of order 4. Nodes with 1, 2, or 3 keys separating 2, 3 or 4 child nodes, respectively.</answer>
            </question>

            <question id="datastructures-implementation-avl-tree">
                <text>AVL Tree</text>
                <link>https://en.wikipedia.org/wiki/AVL_tree</link>
                <answer>After an insert or deletion, rotates the lowest node whose child nodes' heights differ by more than 1.</answer>
            </question>

            <question id="datastructures-implementation-red-black-tree">
                <text>Red-Black Tree</text>
                <link>https://en.wikipedia.org/wiki/Red%E2%80%93black_tree</link>
                <answer>After an insert or deletion, rotates the lowest nodes that do not satisfy the coloring constraints: Root is black. All leaves are black. All children of red nodes are black. All paths to leaves contains the same number of black nodes.</answer>
            </question>

            <question id="datastructures-implementation-cartesian-tree">
                <text>Cartesian Tree</text>
                <link>https://en.wikipedia.org/wiki/Cartesian_tree#Efficient_construction</link>
                <answer>Construct the tree in (amortized) O(n) time by adding each node to the previous node, walking up the tree and splitting an edge if necessary, making children into left nodes.</answer>
            </question>

            <question id="datastructures-implementation-trie">
                <text>Trie (Digital Tree, Prefix Tree)</text>
                <link>https://en.wikipedia.org/wiki/Trie</link>
                <answer>Keys are defined by their position in the tree, with each edge being the next character (or bit) of the key, and with values associated with leaf nodes.</answer>
            </question>

            <question id="datastructures-implementation-radix-tree">
                <text>Radix Tree (Radix Trie, Compact Prefix Tree)</text>
                <link>https://en.wikipedia.org/wiki/Radix_tree</link>
                <answer>Keys are defined by their position in the tree, with each edge being the next chunk of the key, and with values associated with leaf nodes.</answer>
            </question>

            <question id="datastructures-implementation-suffix-tree">
                <text>Suffix Tree</text>
                <link>https://en.wikipedia.org/wiki/Suffix_tree</link>
                <answer>Compressed Trie, with text suffixes as keys and text positions as values.</answer>
            </question>

            <question id="datastructures-implementation-van-emde-boas-tree">
                <text>Van Emde Boas Tree</text>
                <link>https://en.wikipedia.org/wiki/Van_Emde_Boas_tree</link>
                <answer>A hierarchy of of clusters that summarize less sparse clusters, each with a min and max.</answer>
            </question>
        </subsection>

        <subsection id="datastructures-implementations-others">
            <title>Others</title>

            <question id="datastructures-implementation-bloom-filter">
                <text>Bloom Filter</text>
                <link>https://en.wikipedia.org/wiki/Bloom_filter</link>
                <answer>A bit array and a set of hash functions to map keys to positions.</answer>
            </question>

            <question id="datastructures-implementation-union-find">
                <text>Union Find (Disjoint Set)</text>
                <link>https://en.wikipedia.org/wiki/Disjoint-set_data_structure</link>
                <answer>A tree-based data struture, for instance in an array. Each position's value is the position of its parent.</answer>
            </question>

            <question id="datastructures-implementation-adjacency-list">
                <text>Adjacency List</text>
                <link>https://en.wikipedia.org/wiki/Adjacency_list</link>
                <answer>A list of each node and its edges.</answer>
            </question>

            <question id="datastructures-implementation-adjacency-matrix">
                <text>Adjacency Matrix</text>
                <link>https://en.wikipedia.org/wiki/Adjacency_matrix</link>
                <answer>A 2-dimensional array of node connections.</answer>
            </question>

            <question id="datastructures-implementation-singly-linked-list">
                <text>Singly Linked List</text>
                <link>https://en.wikipedia.org/wiki/Linked_list#Singly_linked_list</link>
                <answer>Nodes with a data field and a pointer to the next node..</answer>
            </question>

            <question id="datastructures-implementation-doubly-linked-list">
                <text>Doubly Linked List</text>
                <link>https://en.wikipedia.org/wiki/Doubly_linked_list</link>
                <answer>Nodes with a data field and both a pointer to the next node and a pointer to the previous node.</answer>
            </question>

            <question id="datastructures-implementation-hash-table">
                <text>Hash Table</text>
                <link>https://en.wikipedia.org/wiki/Hash_table</link>
                <answer>A hash function that maps keys to buckets in an array, resolving collisions either by Separate Chaining (linked list of items in each bucket) or Open Addressing (items stored in next available bucket).</answer>
            </question>

            <question id="datastructures-implementation-skip-list">
                <text>Skip List</text>
                <link>https://en.wikipedia.org/wiki/Skip_list</link>
                <answer>A linked hierarchy of ordered elements, starting with the sparsest subsequence.</answer>
            </question>

            <question id="datastructures-implementation-splay-tree">
                <text>Splay Tree</text>
                <link>https://en.wikipedia.org/wiki/Splay_tree</link>
                <answer>A binary search tree. After insertion, deletion, or searching, the node is rotated to become the root.</answer>
            </question>

            <question id="datastructures-implementation-k-d-tree">
                <text>K-D Tree</text>
                <link>https://en.wikipedia.org/wiki/K-d_tree</link>
                <answer>A binary tree. Each node defines a hyperplane and its left and right children are either side of that hyperplane. Typically the hyperplane will be chosen by cycling through the axes as we move down the tree. Each node is the median of the points in its subtree.</answer>
            </question>
        </subsection>

        <subsection id="datastructures-implementations-heaps">
            <title>Heaps</title>

            <question id="datastructures-implementation-heap">
                <text>Heap</text>
                <link>https://en.wikipedia.org/wiki/Heap_(data_structure)</link>
                <answer>Usually implemented with an array. The K children of position i are from Ki+1 to Ki+K.</answer>
            </question>

            <!-- TODO: How is it kept complete? -->
            <question id="datastructures-implementation-binary-heap">
                <text>Binary Heap</text>
                <link>https://en.wikipedia.org/wiki/Binary_heap</link>
                <answer>Usually implemented with an array. The children of position i are at 2i+1 and 2i+2.</answer>
            </question>

            <question id="datastructures-implementation-binomial-heap">
                <text>Binomial Heap</text>
                <link>https://en.wikipedia.org/wiki/Binomial_heap</link>
                <answer>Store the roots of the binomial trees in an ordered list. Find minimum by finding the minimum root. Merge trees by making the larger root a child of the smaller root.</answer>
            </question>

            <!-- TODO: Binomial heap takes O(log n) time in all operations while Fibonacci heap takes amortized running time O(1) in Insert, find, decrease key operations and O(log n) time in delete min, delete operations. -->
            <!-- TODO: every Binomial heap is a Fibonacci heap but every Fibonacci heap isn't Binomial heap. -->
            <question id="datastructures-implementation-fibonacci-heap">
                <text>Fibonacci Heap</text>
                <link>https://en.wikipedia.org/wiki/Fibonacci_heap</link> <!-- This is good: http://www.growingwiththeweb.com/2014/06/fibonacci-heap.html -->
                <answer>A collection of heap-ordered trees, which are like binomial trees, but do not need to be restructured upon node removal. Each node has a doubly-linked list of its children. The roots of the trees are in a circular doubly-linked list. Nodes are marked when restructuring is necessary but that cleanup operations are deferred.</answer>
            </question>

            <question id="datastructures-implementation-treap">
                <text>Treap</text>
                <link>https://en.wikipedia.org/wiki/Treap</link>
                <answer>A cartesian tree that satisfies the heap property for random weights. Insert as per node value order and then rotate to maintain heap property for the random weight.</answer>
            </question>
        </subsection>
    </section>

    <section id="datastructures-tree-operations">
        <title>Tree Operations</title>

        <subsection id="datastructures-tree-operations-bst" answers_as_choices="true">
            <title>Binary Search Tree</title>
            <link>https://en.wikipedia.org/wiki/Binary_search_tree#Operations</link>

            <question id="datastructures-tree-operations-bst-search">
                <text>Search</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree#Searching</link>
                <answer>Find the node by comparing its key.</answer>
            </question>

            <question id="datastructures-tree-operations-bst-successor">
                <text>Successor</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree#Searching</link>
                <answer>Find the node with the next key in order.</answer>
            </question>

            <question id="datastructures-tree-operations-bst-predecessor">
                <text>Predecessor</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree</link>
                <answer>Find the node with the previous key in order.</answer>
            </question>

            <question id="datastructures-tree-operations-bst-insert">
                <text>Insert</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree#Insertion</link>
                <answer>Add a node with the specified key.</answer>
            </question>

            <question id="datastructures-tree-operations-bst-delete">
                <text>Delete</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree#Deletion</link>
                <answer>Remove a node with the specified key.</answer>
            </question>

            <question id="datastructures-tree-operations-bst-pre-order-traversal">
                <text>Pre-Order Traversal</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Pre-order</link>
                <answer>List the nodes first from the root down the left to the leaf, then back up from left to right.</answer>
            </question>
            <!-- Uses: Duplicate a tree. Build a prefix expression. -->

            <question id="datastructures-tree-operations-bst-in-order-traversal">
                <text>In-Order Traversal</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#In-order</link>
                <answer>Lists the items in sorted order.</answer>
            </question>
            <!-- Uses: List nodes in order -->

            <question id="datastructures-tree-operations-bst-post-order-traversal">
                <text>Post-Order Traversal</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Post-order</link>
                <answer>List the nodes from the bottom of each path up to the root, listing shared nodes last, from left to right.</answer>
            </question>
            <!-- Use: wikipedia says: Post-order traversal while deleting or freeing nodes and values can delete or free an entire binary tree. It can also generate a postfix representation of a binary tree. -->
        </subsection>

        <subsection id="datastructures-tree-implementation-bst" answers_as_choices="true">
            <title>Binary Search Tree: Implementations</title>
            <link>https://en.wikipedia.org/wiki/Binary_search_tree#Operations</link>

            <question id="datastructures-tree-implementation-bst-search">
                <text>Search</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree#Searching</link>
                <answer>Compare with root's key and then search in the left or right subtree, comparing each node's key and then going left or right.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-successor">
                <text>Successor</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree#Searching</link>
                <answer>Find left-most child of right child. Or if there is no right child, find the nearest ancestor that is an ancestor's left child.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-predecessor">
                <text>Predecessor</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree</link>
                <answer>Find right-most child of left child. Or if there is no left child, find the nearest ancestor that is an ancestor's right child.</answer>
            </question>
            <!-- TODO: recursive and iterative implementations? -->

            <question id="datastructures-tree-implementation-bst-insert">
                <text>Insert</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree#Insertion</link>
                <answer>Search for the node's key until we find a null child. Put the node in that position.</answer>
            </question>

            <!-- TODO: 2 versions of delete. One changing values, and one moving nodes. Only earlier CLRS versions copied values.
                 For copying values, see wikipedia or http://www.algolist.net/Data_structures/Binary_search_tree/Removal -->
            <question id="datastructures-tree-implementation-bst-delete">
                <text>Delete</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree#Deletion</link>
                <answer>If there are 2 child nodes: Find the successor. If there is no successor then there is no right child, so replace the node with the left child. If there is a successor, replace the node with the successor, making the node's left child be the successor's left node, making the sucessor's original parent be the successor's right child and making the successor's original right child be the successor's original parent's left child.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-pre-order-traversal-recursive">
                <text>Pre-Order Traversal (Recursive)</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Pre-order</link>
                <answer>Use the current node, recurse into left tree, recurse into right tree.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-pre-order-traversal-iterative">
                <text>Pre-Order Traversal (Iterative)</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Pre-order</link>
                <answer>Put root on stack. while(stack not empty), take from stack, use current node, put right then left on stack.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-in-order-traversal-recursive">
                <text>In-Order Traversal (Recursive)</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#In-order</link>
                <answer>Recurse into left tree, use the current node, recurse into right tree.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-in-order-traversal-iterative">
                <text>In-Order Traversal (Iterative)</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#In-order</link>
                <answer>While(current and stack not empty), if current is null, take from stack, otherwise travel leftwards, adding nodes to the stack. Use the current node. Set current = right node.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-post-order-traversal-recursive">
                <text>Post-Order Traversal (Recursive)</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Post-order</link>
                <answer>Recurse into left tree, recurse into right tree, use the current node.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-post-order-traversal-iterative">
                <text>Post-Order Traversal (Iterative)</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Post-order</link>
                <answer>Use 2 stacks. Put root on stack1. while(stack1 not empty), take from stack1, put on stack2, put left and right on stack1. while(stack2 not empty), take from stack and use.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-left-rotation">
                <text>Left Rotation</text>
                <link>https://en.wikipedia.org/wiki/Tree_rotation</link>
                <answer>The node's right child becomes its parent, with the node as the left child. The right child's left child becomes the node's right child.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-right-rotation">
                <text>Right Rotation</text>
                <link>https://en.wikipedia.org/wiki/Tree_rotation</link>
                <answer>The node's left child becomes its parent, with the node as the right child. The left child's right child becomes the node's left child.</answer>
            </question>

            <!-- TODO: BST Order/Rank. -->

        </subsection>
    </section>


    <section id="datastructures-hash-tables">
        <title>Hash Tables</title>
        <link>https://en.wikipedia.org/wiki/Hash_table</link>

        <subsection id="datastructures-hash-tables-collision-resolution" answers_as_choices="true">
            <title>Collision Resolution</title>
            <link>https://en.wikipedia.org/wiki/Hash_table#Collision_resolution</link>

            <question id="datastructures-hash-tables-collision-resolution-chaining">
                <text>Separate chaining (open hashing)</text>
                <link>https://en.wikipedia.org/wiki/Hash_table#Separate_chaining</link>
                <answer>Each bucket is independent, and has a list of entries with the same index.</answer>
            </question>

            <question id="datastructures-hash-tables-collision-resolution-open-addressing">
                <text>Open addressing (closed hashing)</text>
                <link>https://en.wikipedia.org/wiki/Hash_table#Open_addressing</link>
                <answer>All entry records are stored in the bucket array itself. Lookups may examine a series of buckets.</answer>
            </question>

            <question id="datastructures-hash-tables-collision-resolution-robin-hood-hashing">
                <text>Robin Hood hashing</text>
                <link>https://en.wikipedia.org/wiki/Hash_table#Robin_Hood_hashing</link>
                <answer>A key will be relocated if its probe count is higher than for the new key.</answer>
            </question>

            <question id="datastructures-hash-tables-collision-resolution-2-choice-hashing">
                <text>2-choice hashing</text>
                <link>https://en.wikipedia.org/wiki/2-choice_hashing</link>
                <answer>2 hash functions provide 2 potential positions for a key. The key is placed where there would be fewer collisions.</answer>
            </question>
        </subsection>

        <!-- TODO: Need to find better advantages/disadvantages for these. -->
        <subsection id="datastructures-hash-tables-collision-resolution-advantages" answers_as_choices="true">
            <title>Collision Resolution: Advantages/Disadvantages</title>
            <link>https://en.wikipedia.org/wiki/Hash_table#Collision_resolution</link>

            <question id="datastructures-hash-tables-collision-resolution-advantages-chaining">
                <text>Separate chaining (open hashing)</text>
                <link>https://en.wikipedia.org/wiki/Hash_table#Separate_chaining</link>
                <answer>Advantages: Simple implementation. Avoids rehashing. Disadvantage: Pointer chasing causes cache misses. Extra space.</answer>
            </question>

            <question id="datastructures-hash-tables-collision-resolution-advantages-open-addressing">
                <text>Open addressing (closed hashing)</text>
                <link>https://en.wikipedia.org/wiki/Hash_table#Open_addressing</link>
                <answer>Advantage: Data locality gives good cache performance. Disdvantage: Requires reallocation and rehashing.</answer>
            </question>

            <question id="datastructures-hash-tables-collision-resolution-advantages-robin-hood-hashing">
                <text>Robin Hood hashing</text>
                <link>https://en.wikipedia.org/wiki/Hash_table#Robin_Hood_hashing</link>
                <answer>Advantage: Reduces worst case search times.</answer>
            </question>

            <!-- TODO:
            <question id="datastructures-hash-tables-collision-resolution-advantages-2-choice-hashing">
                <text>2-choice hashing</text>
                <link>https://en.wikipedia.org/wiki/2-choice_hashing</link>
                <answer>TODO</answer>
            </question>
            -->
        </subsection>

        <subsection id="datastructures-hash-tables-open-addressing-strategies" answers_as_choices="true">
            <title>Open addressing strategies</title>
            <link>https://en.wikipedia.org/wiki/Open_addressing</link>

            <question id="datastructures-hash-tables-open-addressing-strategy-probe-sequence">
                <text>Probe sequence</text>
                <link>https://en.wikipedia.org/wiki/Open_addressing</link>
                <answer>The buckets are examined, starting with the hashed-to slot and proceeding in some probe sequence, until an unoccupied slot is found.</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-strategy-coalesced-hashing">
                <text>Coalesced hashing</text>
                <link>https://en.wikipedia.org/wiki/Coalesced_hashing</link>
                <answer>Hybrid of separate chaining and open addressing, chaining from filled buckets to unused buckets.</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-strategy-cuckoo-hashing">
                <text>Cuckoo hashing</text>
                <link>https://en.wikipedia.org/wiki/Cuckoo_hashing</link>
                <answer>The key is re-hashed with other hash functions to find an empty bucket. (All hashes may be tried during lookup.) If all collide, the existing key is re-hashed, possibly causing further re-hashing. If this eventually fails, the table is resized.</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-strategy-hopscotch-hashing">
                <text>Hopscotch hashing</text>
                <link>https://en.wikipedia.org/wiki/Hopscotch_hashing</link>
                <answer>The key is always in the neighborhood of the original bucket. If necessary, existing items are moved, though without moving them outside of their neighbourhoods.</answer>
            </question>
        </subsection>

        <!-- TODO: Need to find better advantages/disadvantages for these. -->
        <subsection id="datastructures-hash-tables-open-addressing-strategies-advantages" answers_as_choices="true">
            <title>Open addressing strategies: Advantages</title>
            <link>https://en.wikipedia.org/wiki/Open_addressing</link>

            <question id="datastructures-hash-tables-open-addressing-strategy-advantage-probe-sequence">
                <text>Probe sequence</text>
                <link>https://en.wikipedia.org/wiki/Open_addressing</link>
                <answer>Fast insertion and fast search.</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-strategy-advantage-coalesced-hashing">
                <text>Coalesced hashing</text>
                <link>https://en.wikipedia.org/wiki/Coalesced_hashing</link>
                <answer>No clustering effects; in fact, the table can be efficiently filled to a high density.</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-strategy-advantage-cuckoo-hashing">
                <text>Cuckoo hashing</text>
                <link>https://en.wikipedia.org/wiki/Cuckoo_hashing</link>
                <answer>Constant lookup time in the worst case, and constant amortized time for insertions and deletions.</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-strategy-advantage-hopscotch-hashing">
                <text>Hopscotch hashing</text>
                <link>https://en.wikipedia.org/wiki/Hopscotch_hashing</link>
                <answer>Works well even when the load factor grows beyond 0.9. Allows use of simple hash function.</answer>
            </question>
        </subsection>

        <!-- TODO: Deletion in open addressing and coalesced hashing: Use of sentinel. -->
        <!-- TODO: Good load factor. -->

        <subsection id="datastructures-hash-tables-open-addressing-probing" answers_as_choices="true">
            <title>Open addressing probe sequences: Description</title>
            <link>https://en.wikipedia.org/wiki/Open_addressing</link>

            <question id="datastructures-hash-tables-open-addressing-probing-linear-probing">
                <text>Linear probing</text>
                <link>https://en.wikipedia.org/wiki/Linear_probing</link>
                <answer>The interval between probes is fixed — often at 1.</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-probing-quadratic-probing">
                <text>Quadratic probing</text>
                <link>https://en.wikipedia.org/wiki/Quadratic_probing</link>
                <answer>The interval between probes increases linearly (the indices are described by a quadratic function).</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-probing-double-hashing">
                <text>Double hashing</text>
                <link>https://en.wikipedia.org/wiki/Double_hashing</link>
                <answer>The interval between probes is computed by another hash function.</answer>
            </question>
        </subsection>

        <subsection id="datastructures-hash-tables-open-addressing-probing-advantages" answers_as_choices="true">
            <title>Open addressing probe sequences: Advantages/Disadvantages</title>
            <link>https://en.wikipedia.org/wiki/Open_addressing</link>

            <question id="datastructures-hash-tables-open-addressing-probing-advantage-linear-probing">
                <text>Linear probing</text>
                <link>https://en.wikipedia.org/wiki/Linear_probing</link>
                <answer>Advantage: best cache performance. Disadvantage: worst clustering.</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-probing-advantage-quadratic-probing">
                <text>Quadratic probing</text>
                <link>https://en.wikipedia.org/wiki/Quadratic_probing</link>
                <answer>Advantage: good cache performance and minimal clustering.</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-probing-advantage-double-hashing">
                <text>Double hashing</text>
                <link>https://en.wikipedia.org/wiki/Double_hashing</link>
                <answer>Advantage: no clustering. Disadvantage: worst cache performance.</answer>
            </question>
        </subsection>
        <!-- TODO: Load factor definition: = n/m. -->

        <!-- Open Addressng methods:
        last-come first served hashing
        cuckoo hashing -->

        <!-- TODO: Hash functions
        https://en.wikipedia.org/wiki/Category:Hash_function_(non-cryptographic)
        https://en.wikipedia.org/wiki/Jenkins_hash_function#one-at-a-time
        https://en.wikipedia.org/wiki/CityHash
        https://en.wikipedia.org/wiki/Fowler_Noll_Vo_hash
        https://en.wikipedia.org/wiki/MurmurHash
        https://en.wikipedia.org/wiki/Jenkins_hash_function
        https://en.wikipedia.org/wiki/HighwayHash
        https://en.wikipedia.org/wiki/Java_hashCode()
        https://en.wikipedia.org/wiki/Pearson_hashing
        https://en.wikipedia.org/wiki/PJW_hash_function
        -->

    </section>


    <!-- Probabilistic data structures?
         https://en.wikipedia.org/wiki/Category:Probabilistic_data_structures
    -->

    <!-- What data structure to use for problem:
    Set membership, allowing some mistakes: Bloom filter.
    Set membership, allowing fast testing, membership changing ,and set unioning: Union-Find.
    Sparse Graph: Adjacency List
    Dense Graph: Adjacency Matrix

    Singly Linked List
    Doubly Linked List

    Trie (AKA PrefixTree): Text prediction using prefixes. Associative store where the keys share prefixes.
    Radix Tree: IP Routing (Longest Prefix Matching), Inverted Indices
    Suffix Tree: Find longest repeated substring: https://en.wikipedia.org/wiki/Longest_repeated_substring_problem
      Find longest common substring: https://en.wikipedia.org/wiki/Longest_common_substring_problem
      (Can also be done with dynamic programming)
      Find longest palindrome.
    Tree
    Binary Search Tree
    Balanced Binary Tree (advantages of AVL, Red/Black, etc)
    Optimal Binary Search Tree: Access most frequently queried items faster.
    B-Tree: ? To minimize Disk I/O. Optimized for reading and writing large blocks of data - better data locality. Also when it takes longer to access the nodes than to use the obtained data, for instance when the data is on disk.
    Van de Boas Tree: Data locality?
    Skip List
    Heap (AKA Priority Queue) (advantages of different implementations, including Fibonacci Heap)
    Treap?
    Splay Tree: Access recently-queried items faster.
    K-D Tree: Find neighbours in a K-Dimensional space.
    -->

    <!-- Operations on data structures:
    Linked List: Find cycle: Slow and Fast stepping.
    Union-Find: Join a group: Set to same parent.
    -->


    <!-- Longest Common Subsequence: https://en.wikipedia.org/wiki/Longest_common_subsequence_problem -->
    <!-- TODO: https://en.wikipedia.org/wiki/Category:Problems_on_strings -->

</quiz>
