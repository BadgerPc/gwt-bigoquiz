<?xml version="1.0" encoding="UTF-8"?>
<quiz xmlns="http://bigoquiz.com/document" format_version="1" id="graphs">
    <title>Graphs</title>

    <section id="terminology" answers_as_choices="true">
        <title>Terminology</title>
        <question id="terminology-undirected-graph">
            <text>Undirected Graph</text>
            <answer>A graph whose edges are all bidirectional.</answer>
        </question>

        <question id="terminology-directed-graph">
            <text>Directed Graph (Digraph)</text>
            <answer>A graph whose edges go only in one direction.</answer>
        </question>

        <question id="terminology-dag">
            <text>Directed Acylic Graph (DAG)</text>
            <answer>A directed graph with no cycles.</answer>
        </question>

        <question id="terminology-adjacent-vertices">
            <text>Adjacent vertices</text>
            <answer>Vertices joined by an edge.</answer>
        </question>

        <question id="terminology-incident-edges">
            <text>Incident edges</text>
            <answer>Edges that share a vertex.</answer>
        </question>

        <question id="terminology-incident-vertex-of-edge">
            <text>Incident vertex of an edge</text>
            <answer>A vertex connected by the edge.</answer>
        </question>

        <question id="terminology-incident-edge-of-vertex">
            <text>Incident edge of a vertex</text>
            <answer>An edge connected to the vertex.</answer>
        </question>

        <question id="terminology-incident-degree-of-vertex">
            <text>Degree of a vertex</text>
            <answer>The number of edges incident to the vertex.</answer>
        </question>

        <question id="terminology-incident-indegree-of-vertex">
            <text>Indegree of a vertex in a directed graph</text>
            <answer>The number of edges leading to the vertex.</answer>
        </question>

        <question id="terminology-incident-outdegree-of-vertex">
            <text>Outdegree of a vertex in a directed graph</text>
            <answer>The number of edges leading from the vertex.</answer>
        </question>

        <question id="terminology-incident-dfs">
            <text>Depth First Search (DFS)</text>
            <answer>Examine unexplored child vertices first, before examining sibling vertices.</answer>
        </question>

        <question id="terminology-incident-bfs">
            <text>Breadth First Search (BFS)</text>
            <answer>Examine unexplored sibling vertices first, before examining child vertices.</answer>
        </question>

        <question id="terminology-transpose-graph">
            <text>Transpose Graph (Reverse Graph)</text>
            <answer>A version of a directed graph, with each edge reversed.</answer>
        </question>

        <question id="terminology-kernel-dag">
            <text>Kernal DAG (condensation digraph)</text>
            <answer>A directed graph in which the strongly connected components are contracted to become single vertices.</answer>
        </question>
    </section>

    <section id="polynomial-time-problems-definitions" answers_as_choices="true">
        <title>Definitions: Polynomial-Time Problems</title>
        <question id="definition-connected-components">
            <text>Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29</link>
            <answer>Subsets of the vertices in which every vertex is reachable from every other vertex and no other vertices are reachable.</answer>
        </question>

        <question id="definition-weakly-weakly-connected-components">
            <text>Weakly Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29</link>
            <answer>Subsets of the vertices in a directed graph in which every vertex is reachable from every other vertex, if the edges are considered as undirected.</answer>
        </question>

        <question id="definition-strongly-strongly-connected-components">
            <text>Strongly Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Strongly_connected_component</link>
            <answer>Subsets of the vertices in a directed graph in which every vertex is reachable from every other vertex.</answer>
            <note>Strongly connected components must have cycles. A DAG of N nodes will have N strongly connected components.</note>
        </question>

        <question id="definition-topological-sorting">
            <text>Topological Sorting</text>
            <link>https://en.wikipedia.org/wiki/Topological_sorting</link>
            <answer>An ordering of the vertices such that each edge leads only forwards.</answer>
        </question>

        <question id="definition-minimum-spanning-tree">
            <text>Minimum Spanning Tree</text>
            <link>https://en.wikipedia.org/wiki/Minimum_spanning_tree</link>
            <answer>A tree that connects each vertex, using a subset of edges of the minimum weight.</answer>
        </question>
        <!-- TODO: Maximum Spanning Tree, Bottleneck, Cut Property -->

        <question id="definition-shortest-path">
            <text>Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem</link>
            <answer>The shortest path between two specific vertices.</answer>
        </question>

        <question id="definition-transitive-closure">
            <text>Transitive Closure</text>
            <link>https://en.wikipedia.org/wiki/Transitive_reduction</link>
            <answer>Adds direct edges to each vertex, leading to all reachable nodes, to easily answer reachability questions.</answer>
        </question>

        <question id="definition-transitive-reduction">
            <text>Transitive Reduction</text>
            <link>https://en.wikipedia.org/wiki/Transitive_reduction</link>
            <answer>Removes as many edges as possible, optionally also adding edges, while maintaining the same reachability from each vertex to other vertices.</answer>
        </question>

        <question id="definition-bipartite-matching">
            <text>Bipartite Matching</text>
            <link>https://en.wikipedia.org/wiki/Matching_%28graph_theory%29</link>
            <answer>Finds two sets of vertices in which every edge is in both sets.</answer>
        </question>

        <question id="definition-matching">
            <text>Matching</text>
            <link>https://en.wikipedia.org/wiki/Matching_%28graph_theory%29</link>
            <answer>The largest subset of edges in which each vertex has at most one of the edges.</answer>
        </question>

        <question id="definition-eulerian-path">
            <text>Eulerian Path</text>
            <link>https://en.wikipedia.org/wiki/Eulerian_path</link>
            <answer>A tour that visits each edge at least once.</answer>
        </question>

        <question id="definition-eulerian-cycle">
            <text>Eulerian Cycle</text>
            <link>https://en.wikipedia.org/wiki/Eulerian_path</link>
            <answer>A tour that visits each edge only once, returning to the start.</answer>
        </question>

        <question id="definition-edge-connectivity">
            <text>Edge Connectivity</text>
            <link>https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29</link>
            <answer>The smallest subset of edges whose deletion will disconnect the graph.</answer>
        </question>

        <question id="definition-vertex-connectivity">
            <text>Vertex Connectivity</text>
            <link>https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29</link>
            <answer>The smallest subset of vertices whose deletion will disconnect the graph.</answer>
        </question>

        <question id="definition-max-flow">
            <text>Maximum Flow</text>
            <link>https://en.wikipedia.org/wiki/Maximum_flow_problem</link>
            <answer>The maximum flow which can be sent from one specific vertex to another while respecting the maximum capacity of each edge.</answer>
        </question>

        <!-- Missed a couple of "draw nicely" ones out. -->

        <question id="definition-planarity-detection">
            <text>Planarity Detection and Embedding</text>
            <link>https://en.wikipedia.org/wiki/Planarity_testing</link>
            <answer>Arrange the vertices so no edges cross.</answer>
        </question>

    </section>

    <section id="hard-problems-definitions" answers_as_choices="true">
        <title>Definitions: Hard Problems</title>
        <question id="definition-clique">
            <text>Clique</text>
            <link>https://en.wikipedia.org/wiki/Clique_%28graph_theory%29</link>
            <answer>The largest subset of vertices that are all connected to each other by edges.</answer>
        </question>

        <question id="definition-independent-set">
            <text>Independent Set</text>
            <link>https://en.wikipedia.org/wiki/Independent_set_%28graph_theory%29</link>
            <answer>The largest subset of vertices for which, for each vertex, each edge leads to a vertex not in the subset.</answer>
        </question>

        <question id="definition-dominating-set">
            <text>Dominating Set</text>
            <link>https://en.wikipedia.org/wiki/Dominating_set</link>
            <answer>A subset of vertices for which every vertex not in the subset is adjacent to a vertex in the subset.</answer>
        </question>

        <question id="definition-vertex-cover">
            <text>Vertex Cover</text>
            <link>https://en.wikipedia.org/wiki/Vertex_cover</link>
            <answer>The smallest subset of vertices for which, for each vertex, each edge leads to at least one vertex of the subset.</answer>
        </question>

        <question id="definition-tsp">
            <text>Traveling Salesman Problem</text>
            <link>https://en.wikipedia.org/wiki/Travelling_salesman_problem</link>
            <answer>A cycle of minimum cost, visiting each vertex exactly once.</answer>
        </question>

        <question id="definition-hamiltonian-cycle">
            <text>Hamiltonian Cycle</text>
            <link>https://en.wikipedia.org/wiki/Hamiltonian_path</link>
            <answer>A tour that visits each vertex only once, returning to the start.</answer>
        </question>

        <question id="definition-hamiltonian-path">
            <text>Hamiltonian Path</text>
            <link>https://en.wikipedia.org/wiki/Hamiltonian_path</link>
            <answer>A tour that visits each vertex only once.</answer>
        </question>

        <question id="definition-graph-partition">
            <text>Graph Partition</text>
            <link>https://en.wikipedia.org/wiki/Graph_partition</link>
            <answer>A partition of the vertices into roughly equal-sized subsets with a certain maximum spanning edge cost.</answer>
        </question>

        <question id="definition-vertex-coloring">
            <text>Vertex Coloring</text>
            <link>https://en.wikipedia.org/wiki/Graph_partition</link>
            <answer>A coloring of each vertex in which no edge leads to the same color, using the minimum number of colors.</answer>
        </question>

        <question id="definition-edge-coloring">
            <text>Edge Coloring</text>
            <link>https://en.wikipedia.org/wiki/Edge_coloring</link>
            <answer>A coloring of each edge in which no vertex has an edge of the same color, using the minimum number of colors.</answer>
        </question>

        <question id="definition-graph-isomorphism">
            <text>Graph Isomorphism</text>
            <link>https://en.wikipedia.org/wiki/Graph_isomorphism</link>
            <answer>A mapping from one set of vertices to another, such that the sets are identical.</answer>
        </question>

        <question id="definition-steiner-tree">
            <text>Steiner Tree</text>
            <link>https://en.wikipedia.org/wiki/Steiner_tree_problem</link>
            <answer>The smallest tree connecting all vertices, adding intermediate vertices if necessary.</answer>
        </question>

        <question id="definition-feedback-edge-set">
            <text>Feedback Edge Set</text>
            <link>https://en.wikipedia.org/wiki/Feedback_vertex_set</link>
            <answer>The smallest set of edges whose removal results in no cycles existing.</answer>
        </question>

        <question id="definition-feedback-vertex-set">
            <text>Feedback Vertex Set</text>
            <link>https://en.wikipedia.org/wiki/Feedback_vertex_set</link>
            <answer>The smallest set of vertices whose removal results in no cycles existing.</answer>
        </question>
    </section>

    <section id="polynomial-or-np-complete" answers_as_choices="true">
        <title>Polynomial or NP-complete</title>
        <question id="polynomial-or-np-complete-connected-components">
            <text>Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-weakly-weakly-connected-components">
            <text>Weakly Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-strongly-strongly-connected-components">
            <text>Strongly Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Strongly_connected_component</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-topological-sorting">
            <text>Topological Sorting</text>
            <link>https://en.wikipedia.org/wiki/Topological_sorting</link>
            <answer>Polynomial (linear)</answer>
        </question>

        <question id="polynomial-or-np-complete-minimum-spanning-tree">
            <text>Minimum Spanning Tree</text>
            <link>https://en.wikipedia.org/wiki/Minimum_spanning_tree</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-shortest-path">
            <text>Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-transitive-closure">
            <text>Transitive Closure</text>
            <link>https://en.wikipedia.org/wiki/Transitive_reduction</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-transitive-reduction">
            <text>Transitive Reduction</text>
            <link>https://en.wikipedia.org/wiki/Transitive_reduction</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-matching">
            <text>Matching</text>
            <link>https://en.wikipedia.org/wiki/Matching_%28graph_theory%29</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-eulerian-path">
            <text>Eulerian Path</text>
            <link>https://en.wikipedia.org/wiki/Eulerian_path</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-eulerian-cycle">
            <text>Eulerian Cycle</text>
            <link>https://en.wikipedia.org/wiki/Eulerian_path</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-edge-connectivity">
            <text>Edge Connectivity</text>
            <link>https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-vertex-connectivity">
            <text>Vertex Connectivity</text>
            <link>https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-max-flow">
            <text>Maximum Flow</text>
            <link>https://en.wikipedia.org/wiki/Maximum_flow_problem</link>
            <answer>Polynomial</answer>
        </question>

        <!-- Missed a couple of "draw nicely" ones out. -->

        <question id="polynomial-or-np-complete-planarity-detection">
            <text>Planarity Detection and Embedding</text>
            <link>https://en.wikipedia.org/wiki/Planarity_testing</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-clique">
            <text>Clique</text>
            <link>https://en.wikipedia.org/wiki/Clique_%28graph_theory%29</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-independent-set">
            <text>Independent Set</text>
            <link>https://en.wikipedia.org/wiki/Independent_set_%28graph_theory%29</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-dominating-set">
            <text>Dominating Set</text>
            <link>https://en.wikipedia.org/wiki/Dominating_set</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-vertex-cover">
            <text>Vertex Cover</text>
            <link>https://en.wikipedia.org/wiki/Vertex_cover</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-tsp">
            <text>Traveling Salesman Problem</text>
            <link>https://en.wikipedia.org/wiki/Travelling_salesman_problem</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-hamiltonian-cycle">
            <text>Hamiltonian Cycle</text>
            <link>https://en.wikipedia.org/wiki/Hamiltonian_path</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-hamiltonian-path">
            <text>Hamiltonian Path</text>
            <link>https://en.wikipedia.org/wiki/Hamiltonian_path</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-graph-partition">
            <text>Graph Partition</text>
            <link>https://en.wikipedia.org/wiki/Graph_partition</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-vertex-coloring">
            <text>Vertex Coloring</text>
            <link>https://en.wikipedia.org/wiki/Graph_partition</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-2-color-vertex-coloring">
            <text>2-Color Vertex Coloring</text>
            <link>https://en.wikipedia.org/wiki/Graph_coloring#Polynomial_time</link>
            <answer>Polynomial (linear)</answer>
            <note>If a graph can be colored with 2 colors then it is bipartite.</note>
        </question>

        <question id="polynomial-or-np-complete-edge-coloring">
            <text>Edge Coloring</text>
            <link>https://en.wikipedia.org/wiki/Edge_coloring</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-2-color-edge-coloring">
            <text>2-Color Edge Coloring</text>
            <link>https://en.wikipedia.org/wiki/Graph_coloring#Polynomial_time</link>
            <answer>Polynomial (linear)</answer>
            <note>If a graph can be colored with 2 colors then it is bipartite.</note>
        </question>

        <!-- Recognition of graph isomorphism is considered quasi-polymorphic, as of 2015,
        so don't bother with this until it's clearer.
        See https://en.wikipedia.org/wiki/Graph_isomorphism_problem

        <question id="polynomial-or-np-complete-graph-isomorphism">
            <text>Graph Isomorphism</text>
            <link>https://en.wikipedia.org/wiki/Graph_isomorphism</link>
            <answer>NP-complete</answer>
        </question>
        -->

        <question id="polynomial-or-np-complete-steiner-tree">
            <text>Steiner Tree</text>
            <link>https://en.wikipedia.org/wiki/Steiner_tree_problem</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-feedback-edge">
            <text>Feedback Edge / Vertex Set</text>
            <link>https://en.wikipedia.org/wiki/Feedback_vertex_set</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-longest-path">
            <text>Longest Path</text>
            <link>https://en.wikipedia.org/wiki/Longest_path_problem</link>
            <answer>NP-complete</answer>
            <!-- Note: It's a bit like the travelling salesman problem. -->
            <!-- Really it is NP-hard, but the decision problem (is there a path of length k) is NP-complete.) -->
        </question>
        <!-- TODO: Longest simple weighted path (involving bitonic?) v. longest simple unweighted path. -->
    </section>

    <section id="graph-algorithm-purposes-shortest-path" answers_as_choices="true">
        <title>Graph Algorithm Purposes: Shortest Path</title>

        <question id="purpose-bellmann-ford">
            <text>Bellmann-Ford Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm</link>
            <answer>Single-Source Shortest Path (with negative edges).</answer>
            <!-- TODO: Bellmann-Ford also allows distributed computation. -->
            <!-- TODO: Optimizations --> <!-- TODO: Uses: Internet Routing -->
            <!-- TODO: Can detect negative cycles, but cannot then find a shortest path. -->
        </question>

        <question id="purpose-floyd-warshall">
            <text>Floyd Warshall Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm</link>
            <answer>All Pairs Shortest Path, for dense graphs (with negative edges).</answer>
        </question>

        <question id="purpose-johnsons">
            <text>Johnson's Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Johnson's_algorithm</link>
            <answer>All Pairs Shortest Path, for sparse graphs (with negative edges).</answer>
        </question>

        <question id="purpose-n-dijkstra">
            <text>n * Dijkstra's Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Dijkstra's_algorithm</link>
            <answer>All Pairs Shortest Path, for sparse graphs (no negative edges).</answer>
        </question>
    </section>

    <section id="graph-algorithm-purposes-others" answers_as_choices="true">
        <title>Graph Algorithm Purposes: Others</title>
        <question id="purpose-prims">
            <text>Prim's Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Prim's_algorithm</link>
            <answer>Minimum Spanning Tree, for dense graphs.</answer>
        </question>

        <question id="purpose-kruskals">
            <text>Kruskal's Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Kruskal's_algorithm</link>
            <answer>Minimum Spanning Tree, for sparse graphs.</answer>
        </question>

        <question id="purpose-ford-fulkerson">
            <text>Ford-Fulkerson (Edmonds-Karp) Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm</link>
            <answer>Maximum Flow (sparse graphs).</answer>i
        </question>

        <question id="purpose-dinic">
            <text>Dinic's Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Dinic's_algorithm</link>
            <answer>Maximum Flow (sparse graphs).</answer>
        </question>

        <question id="purpose-push-relabel">
            <text>Push-Relabel Algorithm (Preflow-Push)</text>
            <link>https://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm</link>
            <answer>Maximum Flow (dense graphs).</answer>
        </question>
    </section>

    <section id="graph-algorithm-definitions-shortest-path" answers_as_choices="true" and_reverse="true">
        <title>Graph Algorithm Definitions: Shortest Path</title>
        <link>https://en.wikipedia.org/wiki/Shortest_path_problem</link>
        <question id="definition-dijkstras">
            <text>Dijkstra's Algorithm for Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Dijkstra's_algorithm</link>
            <answer>Choose the outgoing edge with the least total path cost, starting with a zero-cost edge to the start vertex. Look at the edge's destination vertex and store the total path costs (and, optionally, the predecessor) for each outgoing edge's vertex. Repeat until we reach the destination. Use, and update, a min heap (priority queue) to choose the outgoing edge with the lowest total cost.</answer>
        </question>

        <question id="definition-bidirectional-dijkstra">
            <text>Dijkstra's Algorithm for Shortest Path (Bidirectional)</text>
            <link>https://en.wikipedia.org/wiki/Bidirectional_search</link> <!-- I learned this in: https://www.youtube.com/watch?v=CHvQ3q_gJ7E -->
            <answer>Alternate between forward search, from the source, and backward search from the destination. Terminate when the same vertex has been removed from the priority queue. Find the vertex with the minimum forward plus backward length.</answer>
        </question>

        <question id="definition-bellmann-ford">
            <text>Bellmann-Ford Algorithm for Single-Source Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm</link>
            <answer>Start with 0 cost for the source vertex, and infinity for all other vertices. Then, for each vertex, examine each edge, to calculate the total path cost (or infinity) to reach the adjacent vertices, reducing the stored cost if it is less. Repeat the examination of edges, and the recalculation, n-1 times, or until there is no change. Do 1 extra iteration to detect negative cycles.</answer>
        </question>

        <question id="definition-floyd-warshall">
            <text>Floyd Warshall Algorithm for All Pairs Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm</link>
            <answer>Examine every path from vertex i to vertex j, using k edges, by examining i to j using k-1 edges and examining i to k to j using k-1 edges. To detect negative cycles, check for a negative cost from a node to itself.</answer>
        </question>

        <question id="definition-johnsons">
            <text>Johnson's Algorithm for All Pairs Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Johnson's_algorithm</link>
            <answer>Add one vertex to the graph, with zero-length edges to every other vertex. Run Bellmann-Ford to get the shortest path from the new vertex to every other. Reweight the original graph's edges by adding the difference of the edge's start and end vertices' paths from s. Then call Dijkstra's algorithm for each pair of vertices, subtracting the reweighting difference from the result.</answer>
        </question>
    </section>

    <section id="graph-algorithm-definitions-mst" answers_as_choices="true" and_reverse="true">
        <title>Graph Algorithm Definitions: MST</title>
        <question id="definition-prims">
            <text>Prim's Algorithm for Minimum Spanning Tree</text>
            <link>https://en.wikipedia.org/wiki/Prim's_algorithm</link>
            <answer>Start with an arbitrary vertex. Find the lowest-cost outgoing edge and add its destination to the tree. Repeat until all vertices are in the tree.</answer>
            <note>This is usually implemented with a priority queue (heap).</note>
        </question>

        <!-- Note: Kruskals is like a greedy algorithm for finding clusters, though that aborts early, to leave k clusters.
             https://www.coursera.org/learn/algorithm-design-analysis-2/lecture/QWubN/application-to-clustering  -->
        <question id="definition-kruskals">
            <text>Kruskal's Algorithm for Minimum Spanning Tree</text>
            <link>https://en.wikipedia.org/wiki/Kruskal's_algorithm</link>
            <answer>Iterate through all edges, in increasing order of their cost. Join each edge's vertices by adding them to a Union-Find (Disjoint Set), if they are not already joined, remembering the edges added.</answer>
        </question>
    </section>

    <section id="graph-algorithm-definitions-max-flow" answers_as_choices="true" and_reverse="true">
        <title>Graph Algorithm Definitions: Max Flow</title>
        <question id="definition-ford-fulkerson">
            <text>Ford-Fulkerson Algorithm for Maximum Flow</text>
            <link>https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm</link>
            <answer>Define a residual graph with reverse edges. Find a path in that graph. Augment the path with its bottleneck capacity, decreasing capacity on used edges, increasing on reverse edges. Repeat until there is no path.</answer>
        </question>

        <question id="definition-dinic">
            <text>Dinic's Algorithm for Maximum Flow</text>
            <link>https://en.wikipedia.org/wiki/Dinic's_algorithm</link>
            <answer>Ford-Fulkerson using BFS to find the path in each iteration.</answer>
        </question>

        <question id="definition-push-relabel">
            <text>Push-Relabel Algorithm for Maximum Flow (Preflow-Push)</text>
            <link>https://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm</link>
            <answer>Define a residual graph with reverse edges. Define heights for all vertices, starting with n for the source and 0 for others. Define excesses for each vertex. Starting with the source, repeatedly find the highest vertex that has excess and push flow along its downhill edges, increasing the excess on the edges' destination vertices. Repeat until there are no vertices with excess.</answer>
        </question>

        <!-- TODO: Kruskal's can be used to find clusters, stopping early. -->
        <!-- TODO: Uses: Floyd-Warshall: Transitive Closure of a binary relation. -->
    </section>

    <!-- This is much like a reverse of the graph-algorithm-purposes-shortest-path section,
      but with some useful rewording to really exercise understanding. -->
    <section id="graph-algorithm-choice-shortest-path" answers_as_choices="true" and_reverse="true">
        <title>Graph Algorithms Choice: Shortest path</title>
        <question id="algorithm-for-shortest-path-unweighted">
            <text>Single Source Shortest Path (unweighted)</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem#Unweighted_graphs</link>
            <answer>Breadth First Search</answer>
        </question>

        <question id="algorithm-for-shortest-path-weighted-directed-acyclic">
            <text>Single Source Shortest Path (weighted, directed, acyclic)</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem#Directed_acyclic_graphs</link>
            <!-- http://www.geeksforgeeks.org/shortest-path-for-directed-acyclic-graphs/ -->
            <!-- https://www.youtube.com/watch?v=ePqBaDRHkdk -->
            <!-- Page 491 of TADM. -->
            <!-- TODO: O(|V| + |E|) -->
            <answer>Topological sort. Then Find minimum distance to adjacent nodes by examining nodes in order, starting with source, until destination.</answer>
        </question>

        <question id="algorithm-for-shortest-path-weighted-directed-non-negative-weights">
            <text>Single Source Shortest Path (weighted, directed, with non-negative weights)</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem#Directed_graphs_with_nonnegative_weights</link>
            <answer>Dijkstra's algorithm</answer>
        </question>

        <question id="algorithm-for-shortest-path-weighted-directed-with-negative-weights">
            <text>Single Source Shortest Path (weighted, directed, with negative weights but no negative cycles)</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem#Directed_graphs_with_nonnegative_weights</link>
            <answer>Bellman-Ford algorithm</answer>
        </question>

        <question id="algorithm-for-all-pairs-shortest-path-with-non-negative-weights">
            <text>All Pairs Shortest Path (with non-negative weights)</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem#All-pairs_shortest_paths</link>
            <answer>Floyd-Warshall (for dense graphs) or repeated Dijkstra's algorithm (for sparse graphs).</answer>
        </question>

        <question id="algorithm-for-all-pairs-shortest-path-with-negative-weights">
            <text>All Pairs Shortest Path (with negative weights but no negative cycles)</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem#All-pairs_shortest_paths</link>
            <answer>Floyd-Warshall (for dense graphs) or Johnson's (for sparse graphs).</answer>
        </question>
    </section>

    <section id="graph-algorithm-choice-connected-components" answers_as_choices="true" and_reverse="true">
        <title>Graph Algorithms Choice: Connected Components</title>

        <question id="algorithm-for-connected-components">
            <text>Connected Components in an undirected graph</text>
            <link>https://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29</link>
            <answer>Depth First Search or Breadth First Search.</answer>
        </question>

        <question id="algorithm-for-weakly-connected-components">
            <text>Weakly Connected Components in a directed graph</text>
            <link>https://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29</link>
            <answer>Make edges undirected, then Depth First Search or Breadth First Search.</answer>
        </question>

        <question id="algorithm-for-stongly-connected-components">
            <text>Strongly Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Strongly_connected_component</link>
            <answer>Kosaraju's Algorithm: Depth First Search on the reversed graph, to get a topological sort, then call DFS on each vertex in that order, assigning a new ID for eaach DFS call.</answer>
            <note>In the second DFS, pop from the first DFS's stack.</note>
            <!-- TODO: Sedgewick's Algorithms book says to DFS on the reversed graph first: https://www.youtube.com/watch?v=PH4L30XRhJE
            and Tim Roughgarden's course says this too: https://www.youtube.com/watch?v=PZQ0Pdk15RA
            but other descriptions DFS first on the real graph and then on a reversed graph. -->
        </question>
    </section>

    <section id="graph-algorithm-choice-others" answers_as_choices="true" and_reverse="true">
        <title>Graph Algorithms Choice: Others</title>

        <question id="algorithm-for-topological-sort">
            <text>Topological Sort</text>
            <link>https://en.wikipedia.org/wiki/Topological_sorting</link>
            <answer>Depth First Search to order vertices by their completion time, starting from each still unexplored vertex. Then reverse that order.</answer>
            <note>This is only possible on DAGs (Directed Acyclic Graphs)</note>
        </question>

        <question id="algorithm-for-minimum-spanning-tree">
            <text>Minimum Spanning Tree</text>
            <link>https://en.wikipedia.org/wiki/Minimum_spanning_tree</link>
            <answer>Kruskal's, Prim's, or Boruvka's algorithm</answer>
        </question>

        <question id="algorithm-for-transitive-closure">
            <text>Transitive Closure</text>
            <link>https://en.wikipedia.org/wiki/Transitive_reduction</link>
            <answer>BFS or DFS, or modify Floyd-Warshall's algorithm to calculate only reachability.</answer>
        </question>

        <question id="algorithm-for-bipartite-matching-unweighted">
            <text>Bipartite Matching (unweighted)</text>
            <link>https://en.wikipedia.org/wiki/Matching_%28graph_theory%29#In_unweighted_bipartite_graphs</link>
            <answer>A Maximum Flow algorithm after adding source and sink vertices and setting all edge capacities to 1.</answer>
        </question>

        <question id="algorithm-for-bipartite-matching-weighted">
            <text>Bipartite Matching (weighted)</text>
            <link>https://en.wikipedia.org/wiki/Matching_%28graph_theory%29#In_weighted_bipartite_graphs</link>
            <answer>Hungarian Algorithm.</answer>
            <!-- TODO: Application to assignment problem. -->
        </question>

        <!-- TODO?
         <question id="algorithm-for-matching">
            <text>Graph Matching</text>
            <link>https://en.wikipedia.org/wiki/Matching_%28graph_theory%29</link>
            <answer>.</answer>
        </question>
        -->

        <question id="algorithm-for-maximum-flow">
            <text>Maximum Flow</text>
            <link>https://en.wikipedia.org/wiki/Maximum_flow_problem</link>
            <answer>Edmonds-Karp (Ford-Fulkerson), Dinic's, or Push-Relabel.</answer>
        </question>
    </section>

    <section id="graph-stack-or-queue" answers_as_choices="true" and_reverse="true">
        <title>Stack or Queue</title>

        <question id="stack-or-queue-bfs">
            <text>Breadth First Search iterative implementation</text>
            <link>https://en.wikipedia.org/wiki/Breadth-first_search</link>
            <answer>Queue</answer>
        </question>

        <question id="stack-or-queue-dfs">
            <text>Depth First Search iterative implementation</text>
            <link>https://en.wikipedia.org/wiki/Depth-first_search</link>
            <answer>Stack</answer>
            <note>Or via recursion, using the implicit call stack.</note>
        </question>
    </section>

    <!-- TODO: This needs an example of a dense graph that occurs naturally,
    instead of being a subset of a sparse graph.
    Note: In sparse graphs, the number of edges increases linearly with the number of vertices.
    <section  id="graph-sparse-or-dense" answers_as_choices="true" >
        <title>Sparse or Dense Graphs</title>

        <question id="graph-sparse-or-dense-list">
            <text>Linked List</text>
            <answer>Sparse</answer>
        </question>

        <question id="graph-sparse-or-dense-tree">
            <text>Tree</text>
            <answer>Sparse</answer>
        </question>

        <question id="graph-sparse-or-dense-transport-network">
            <text>Transport network</text>
            <answer>Sparse</answer>
        </question>

        <question id="graph-sparse-or-dense-social-network">
            <text>Social network</text>
            <answer>Sparse</answer>
        </question>
    </section>
    -->

    <!-- Types of graph. This duplicates ideas from the algorithms needed to identify these graphs, but that is helpful.
    Planar. Hypergraph. Connected -->

</quiz>
