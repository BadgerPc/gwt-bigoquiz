<?xml version="1.0" encoding="UTF-8"?>
<quiz xmlns="http://bigoquiz.com/document" format_version="1" id="graphs">
    <title>Graphs</title>

    <section id="polynomial-time-problems-definitions" answers_as_choices="true">
        <title>Definitions: Polynomial-Time Problems</title>
        <question id="definition-connected-components">
            <text>Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29</link>
            <answer>Subsets of the vertices in which every vertex is reachable from every other vertex and no other vertices are reachable.</answer>
        </question>

        <question id="definition-weakly-weakly-connected-components">
            <text>Weakly Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29</link>
            <answer>Subsets of the vertices in a directed graph in which every vertex is reachable from every other vertex, if the edges are considered as undirected.</answer>
        </question>

        <question id="definition-strongly-strongly-connected-components">
            <text>Strongly Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Strongly_connected_component</link>
            <answer>Subsets of the vertices in a directed graph in which every vertex is reachable from every other vertex.</answer>
        </question>

        <question id="definition-topological-sorting">
            <text>Topological Sorting</text>
            <link>https://en.wikipedia.org/wiki/Topological_sorting</link>
            <answer>An ordering of the vertices such that each edge leads only forwards.</answer>
        </question>

        <question id="definition-minimum-spanning-tree">
            <text>Minimum Spanning Tree</text>
            <link>https://en.wikipedia.org/wiki/Minimum_spanning_tree</link>
            <answer>A tree that connects each vertex, using a subset of edges of the minimum weight.</answer>
        </question>

        <question id="definition-shortest-path">
            <text>Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem</link>
            <answer>The shortest path between two specific vertices.</answer>
        </question>

        <question id="definition-transitive-closure">
            <text>Transitive Closure</text>
            <link>https://en.wikipedia.org/wiki/Transitive_reduction</link>
            <answer>Adds direct edges to each vertex, leading to all reachable nodes, to easily answer reachability questions.</answer>
        </question>

        <question id="definition-transitive-reduction">
            <text>Transitive Reduction</text>
            <link>https://en.wikipedia.org/wiki/Transitive_reduction</link>
            <answer>Removes as many edges as possible, optionally also adding edges, while maintaining the same reachability from each vertex to other vertices.</answer>
        </question>

        <question id="definition-bipartite-matching">
            <text>Bipartite Matching</text>
            <link>https://en.wikipedia.org/wiki/Matching_%28graph_theory%29</link>
            <answer>Finds two sets of vertices in which every edge is in both sets.</answer>
        </question>

        <question id="definition-matching">
            <text>Matching</text>
            <link>https://en.wikipedia.org/wiki/Matching_%28graph_theory%29</link>
            <answer>The largest subset of edges in which each vertex has at most one of the edges.</answer>
        </question>

        <question id="definition-eulerian-path">
            <text>Eulerian Path</text>
            <link>https://en.wikipedia.org/wiki/Eulerian_path</link>
            <answer>A tour that visits each edge at least once.</answer>
        </question>

        <question id="definition-eulerian-cycle">
            <text>Eulerian Cycle</text>
            <link>https://en.wikipedia.org/wiki/Eulerian_path</link>
            <answer>A tour that visits each edge only once, returning to the start.</answer>
        </question>

        <question id="definition-edge-connectivity">
            <text>Edge Connectivity</text>
            <link>https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29</link>
            <answer>The smallest subset of edges whose deletion will disconnect the graph.</answer>
        </question>

        <question id="definition-vertex-connectivity">
            <text>Vertex Connectivity</text>
            <link>https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29</link>
            <answer>The smallest subset of vertices whose deletion will disconnect the graph.</answer>
        </question>

        <question id="definition-max-flow">
            <text>Maximum Flow</text>
            <link>https://en.wikipedia.org/wiki/Maximum_flow_problem</link>
            <answer>The maximum flow which can be sent from one specific vertex to another while respecting the maximum capacity of each edge.</answer>
        </question>

        <!-- Missed a couple of "draw nicely" ones out. -->

        <question id="definition-planarity-detection">
            <text>Planarity Detection and Embedding</text>
            <link>https://en.wikipedia.org/wiki/Planarity_testing</link>
            <answer>Arrange the vertices so no edges cross.</answer>
        </question>

        <question id="definition-planarity-detection">
            <text>Planarity Detection and Embedding</text>
            <link>https://en.wikipedia.org/wiki/Planarity_testing</link>
            <answer>Arrange the vertices so no edges cross.</answer>
        </question>

    </section>

    <section id="hard-problems-definitions" answers_as_choices="true">
        <title>Definitions: Hard Problems</title>
        <question id="definition-clique">
            <text>Clique</text>
            <link>https://en.wikipedia.org/wiki/Clique_%28graph_theory%29</link>
            <answer>The largest subset of vertices that are all connected to each other by edges.</answer>
        </question>

        <question id="definition-independent-set">
            <text>Independent Set</text>
            <link>https://en.wikipedia.org/wiki/Independent_set_%28graph_theory%29</link>
            <answer>The largest subset of vertices for which, for each vertex, each edge leads to a vertex not in the subset.</answer>
        </question>

        <question id="definition-vertex-cover">
            <text>Vertex Cover</text>
            <link>https://en.wikipedia.org/wiki/Vertex_cover</link>
            <answer>The smallest subset of vertices for which, for each vertex, each edge leads to at least one vertex of the subset.</answer>
        </question>

        <question id="definition-tsp">
            <text>Traveling Salesman Problem</text>
            <link>https://en.wikipedia.org/wiki/Travelling_salesman_problem</link>
            <answer>A cycle of minimum cost, visiting each vertex exactly once.</answer>
        </question>

        <question id="definition-hamiltonian-cycle">
            <text>Hamiltonian Cycle</text>
            <link>https://en.wikipedia.org/wiki/Hamiltonian_path</link>
            <answer>A tour that visits each vertex only once, returning to the start.</answer>
        </question>

        <question id="definition-hamiltonian-path">
            <text>Hamiltonian Path</text>
            <link>https://en.wikipedia.org/wiki/Hamiltonian_path</link>
            <answer>A tour that visits each vertex only once.</answer>
        </question>

        <question id="definition-graph-partition">
            <text>Graph Partition</text>
            <link>https://en.wikipedia.org/wiki/Graph_partition</link>
            <answer>A partition of the vertices into roughly equal-sized subsets with a certain maximum spanning edge cost.</answer>
        </question>

        <question id="definition-vertex-coloring">
            <text>Vertex Coloring</text>
            <link>https://en.wikipedia.org/wiki/Graph_partition</link>
            <answer>A coloring of each vertex in which no edge leads to the same color, using the minimum number of colors.</answer>
        </question>

        <question id="definition-edge-coloring">
            <text>Edge Coloring</text>
            <link>https://en.wikipedia.org/wiki/Edge_coloring</link>
            <answer>A coloring of each edge in which no vertex has an edge of the same color, using the minimum number of colors.</answer>
        </question>

        <question id="definition-graph-isomorphism">
            <text>Graph Isomorphism</text>
            <link>https://en.wikipedia.org/wiki/Graph_isomorphism</link>
            <answer>A mapping from one set of vertices to another, such that the sets are identical.</answer>
        </question>

        <question id="definition-steiner-tree">
            <text>Steiner Tree</text>
            <link>https://en.wikipedia.org/wiki/Steiner_tree_problem</link>
            <answer>The smallest tree connecting all vertices, adding intermediate vertices if necessary.</answer>
        </question>

        <question id="definition-feedback-edge-set">
            <text>Feedback Edge Set</text>
            <link>https://en.wikipedia.org/wiki/Feedback_vertex_set</link>
            <answer>The smallest set of edges whose removal results in no cycles existing.</answer>
        </question>

        <question id="definition-feedback-vertex-set">
            <text>Feedback Vertex Set</text>
            <link>https://en.wikipedia.org/wiki/Feedback_vertex_set</link>
            <answer>The smallest set of vertices whose removal results in no cycles existing.</answer>
        </question>
    </section>

    <section id="polynomial-or-np-complete" answers_as_choices="true">
        <title>Polynomial or NP-complete</title>
        <question id="polynomial-or-np-complete-connected-components">
            <text>Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-weakly-weakly-connected-components">
            <text>Weakly Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-strongly-strongly-connected-components">
            <text>Strongly Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Strongly_connected_component</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-topological-sorting">
            <text>Topological Sorting</text>
            <link>https://en.wikipedia.org/wiki/Topological_sorting</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-minimum-spanning-tree">
            <text>Minimum Spanning Tree</text>
            <link>https://en.wikipedia.org/wiki/Minimum_spanning_tree</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-shortest-path">
            <text>Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-transitive-closure">
            <text>Transitive Closure</text>
            <link>https://en.wikipedia.org/wiki/Transitive_reduction</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-transitive-reduction">
            <text>Transitive Reduction</text>
            <link>https://en.wikipedia.org/wiki/Transitive_reduction</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-matching">
            <text>Matching</text>
            <link>https://en.wikipedia.org/wiki/Matching_%28graph_theory%29</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-eulerian-path">
            <text>Eulerian Path</text>
            <link>https://en.wikipedia.org/wiki/Eulerian_path</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-eulerian-cycle">
            <text>Eulerian Cycle</text>
            <link>https://en.wikipedia.org/wiki/Eulerian_path</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-edge-connectivity">
            <text>Edge Connectivity</text>
            <link>https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-vertex-connectivity">
            <text>Vertex Connectivity</text>
            <link>https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-max-flow">
            <text>Maximum Flow</text>
            <link>https://en.wikipedia.org/wiki/Maximum_flow_problem</link>
            <answer>Polynomial</answer>
        </question>

        <!-- Missed a couple of "draw nicely" ones out. -->

        <question id="polynomial-or-np-complete-planarity-detection">
            <text>Planarity Detection and Embedding</text>
            <link>https://en.wikipedia.org/wiki/Planarity_testing</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-planarity-detection">
            <text>Planarity Detection and Embedding</text>
            <link>https://en.wikipedia.org/wiki/Planarity_testing</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-clique">
            <text>Clique</text>
            <link>https://en.wikipedia.org/wiki/Clique_%28graph_theory%29</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-independent-set">
            <text>Independent Set</text>
            <link>https://en.wikipedia.org/wiki/Independent_set_%28graph_theory%29</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-vertex-cover">
            <text>Vertex Cover</text>
            <link>https://en.wikipedia.org/wiki/Vertex_cover</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-tsp">
            <text>Traveling Salesman Problem</text>
            <link>https://en.wikipedia.org/wiki/Travelling_salesman_problem</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-hamiltonian-cycle">
            <text>Hamiltonian Cycle</text>
            <link>https://en.wikipedia.org/wiki/Hamiltonian_path</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-hamiltonian-path">
            <text>Hamiltonian Path</text>
            <link>https://en.wikipedia.org/wiki/Hamiltonian_path</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-graph-partition">
            <text>Graph Partition</text>
            <link>https://en.wikipedia.org/wiki/Graph_partition</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-vertex-coloring">
            <text>Vertex Coloring</text>
            <link>https://en.wikipedia.org/wiki/Graph_partition</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-edge-coloring">
            <text>Edge Coloring</text>
            <link>https://en.wikipedia.org/wiki/Edge_coloring</link>
            <answer>NP-complete</answer>
        </question>

        <!-- Recognition of graph isomorphism is considered quasi-polymorphic, as of 2015,
        so don't bother with this until it's clearer.
        See https://en.wikipedia.org/wiki/Graph_isomorphism_problem

        <question id="polynomial-or-np-complete-graph-isomorphism">
            <text>Graph Isomorphism</text>
            <link>https://en.wikipedia.org/wiki/Graph_isomorphism</link>
            <answer>NP-complete</answer>
        </question>
        -->

        <question id="polynomial-or-np-complete-steiner-tree">
            <text>Steiner Tree</text>
            <link>https://en.wikipedia.org/wiki/Steiner_tree_problem</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-feedback-edge">
            <text>Feedback Edge / Vertex Set</text>
            <link>https://en.wikipedia.org/wiki/Feedback_vertex_set</link>
            <answer>NP-complete</answer>
        </question>
    </section>

    <section id="graph-algorithm-purposes" answers_as_choices="true">
        <title>Graph Algorithm Purposes</title>
        <question id="purpose-prims">
            <text>Prim's Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Prim's_algorithm</link>
            <answer>Minimum Spanning Tree, for dense graphs.</answer>
        </question>
        <question id="purpose-kruskals">
            <text>Kruskal's Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Kruskal's_algorithm</link>
            <answer>Minimum Spanning Tree, for sparse graphs.</answer>
        </question>
        <question id="purpose-dijkstras">
            <text>Dijkstra's Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Dijkstra's_algorithm</link>
            <answer>Shortest Path (no negative edges).</answer>
        </question>
        <question id="purpose-bellmann-ford">
            <text>Bellmann-Ford Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm</link>
            <answer>Single-Source Shortest Path (with negative edges).</answer>
        </question>
        <question id="purpose-floyd-warshall">
            <text>Floyd Warshall Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm</link>
            <answer>All Pairs Shortest Path, for dense graphs (with negative edges).</answer>
        </question>
        <question id="purpose-johnsons">
            <text>Johnson's Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Johnson's_algorithm</link>
            <answer>All Pairs Shortest Path, for sparse graphs (with negative edges).</answer>
        </question>
        <question id="purpose-n-dijkstra">
            <text>n * Dijkstra's Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Dijkstra's_algorithm</link>
            <answer>All Pairs Shortest Path, for sparse graphs (no negative edges).</answer>
        </question>
        <question id="purpose-ford-fulkerson">
            <text>Ford-Fulkerson (Edmonds-Karp) Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm</link>
            <answer>Maximum Flow (sparse graphs).</answer>i
        </question>
        <question id="purpose-dinic">
            <text>Dinic's Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Dinic's_algorithm</link>
            <answer>Maximum Flow (sparse graphs).</answer>
        </question>
        <question id="purpose-push-relabel">
            <text>Push-Relabel Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm</link>
            <answer>Maximum Flow (dense graphs).</answer>
        </question>
    </section>

    <section id="graph-algorithms" answers_as_choices="true" and_reverse="true">
        <title>Graph Algorithms</title>
        <question id="definition-prims">
            <text>Prim's Algorithm for Minimum Spanning Tree</text>
            <link>https://en.wikipedia.org/wiki/Prim's_algorithm</link>
            <answer>Start with an arbitrary vertex. Find the lowest-cost outgoing edge and add its destination to the tree. Repeat until all vertices are in the tree.</answer>
        </question>
        <question id="definition-kruskals">
            <text>Kruskal's Algorithm for Minimum Spanning Tree</text>
            <link>https://en.wikipedia.org/wiki/Kruskal's_algorithm</link>
            <answer>Iterate through all edges, in increasing order of their cost. Join each edge's vertices by adding them to a Union-Find (Disjoint Set), if they are not already joined, remembering the edges added.</answer>
        </question>
        <question id="definition-dijkstras">
            <text>Dijkstra's Algorithm for Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Dijkstra's_algorithm</link>
            <answer>Choose the outgoing edge with the least total path cost, starting with a zero-cost edge to the start vertex. Look at the edge's destination vertex and store the total path costs (and, optionally, the predecessor) for each outgoing edge's vertex. Repeat until we reach the destination. Use, and update, a min heap (priority queue) to choose the outgoing edge with the lowest total cost.</answer>
        </question>
        <question id="definition-bellmann-ford">
            <text>Bellmann-Ford Algorithm for Single-Source Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm</link>
            <answer>Start with 0 cost for the source vertex, and infinity for all other vertices. Then, for each vertex, examine each edge, to calculate the total path cost (or infinity) to reach the adjacent vertices, reducing the stored cost if it is less. Repeat the examination of edges, and recalculation, n-1 times, or until there is no change. Do 1 extra iteration to detect negative cycles.</answer>
        </question>
        <question id="definition-floyd-warshall">
            <text>Floyd Warshall Algorithm for All Pairs Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm</link>
            <answer>Examine every path from vertex i to vertex j, using k edges, by examining i to j using k-1 edges and examining i to k to j using k-1 edges. To detect negative cycles, check for a negative cost from a node to itself.</answer>
        </question>
        <question id="definition-johnsons">
            <text>Johnson's Algorithm for All Pairs Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Johnson's_algorithm</link>
            <answer>Add one vertex to the graph, with zero-length edges to every other vertex. Run Bellmann-Ford to get the shortest path from the new vertex to every other. Reweight the original graph's edges by adding the difference of the edge's start and end vertices' paths from s. Then call Dijkstra's algorithm for each pair of vertices, subtracting the reweighting difference from the result.</answer>
        </question>

        <question id="definition-ford-fulkerson">
            <text>Ford-Fulkerson Algorithm for Maximum Flow</text>
            <link>https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm</link>
            <answer>Define a residual graph with reverse edges. Find a path in that graph. Augment the path with its bottleneck capacity, decreasing capacity on used edges, increasing on reverse edges. Repeat until there is no path.</answer>
        </question>

        <question id="definition-dinic">
            <text>Dinic's Algorithm for Maximum Flow</text>
            <link>https://en.wikipedia.org/wiki/Dinic's_algorithm</link>
            <answer>Ford-Fulkerson using BFS to find the path in each iteration.</answer>
        </question>

        <question id="definition-push-relabel">
            <text>Push-Relabel Algorithm for Maximum Flow</text>
            <link>https://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm</link>
            <answer>Define a residual graph with reverse edges. Define heights for all vertices, starting with n for the source and 0 for others. Define excesses for each vertex. Starting with the source, repeatedly find the highest vertex that has excess and push flow along its downhill edges, increasing the excess on the edges' destination vertices. Repeat until there are no vertices with excess.</answer>
        </question>

        <!-- TODO: Kruskal's can be used to find clusters, stopping early. -->
        <!-- TODO: Uses: Floyd-Warshall: Transitive Closure of a binary relation. -->
    </section>

    <section id="graph-algorithm-choice" answers_as_choices="true" and_reverse="true">
        <title>Graph Algorithms Choice</title>

        <question id="algorithm-for-connected-components">
            <text>Connected Components in an undirected graph</text>
            <link>https://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29</link>
            <answer>Depth First Search or Breadth First Search.</answer>
        </question>

        <question id="algorithm-for-weakly-connected-components">
            <text>Weakly Connected Components in a directed graph</text>
            <link>https://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29</link>
            <answer>Make edges undirected, then Depth First Search or Breadth First Search.</answer>
        </question>

        <question id="algorithm-for-stongly-connected-components">
            <text>Strongly Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Strongly_connected_component</link>
            <answer>Depth First Search from v, then reverse edges and DFS from the latest-completed vertex.</answer>
        </question>

        <question id="algorithm-for-topological-sort">
            <text>Topological Sort</text>
            <link>https://en.wikipedia.org/wiki/Topological_sorting</link>
            <answer>Depth First Search to order vertices by their completion time.</answer>
        </question>

        <question id="algorithm-for-minimum-spanning-tree">
            <text>Minimum Spanning Tree</text>
            <link>https://en.wikipedia.org/wiki/Minimum_spanning_tree</link>
            <answer>Kruskal's, Prim's, or Boruvka's algorithm</answer>
        </question>

        <question id="algorithm-for-shortest-path">
            <text>Single Source Shortest Path (unweighted)</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem</link>
            <answer>Breadth First Search</answer>
        </question>

        <question id="algorithm-for-shortest-path">
            <text>Single Source Shortest Path (weighted)</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem</link>
            <answer>Dijkstra's algorithm, or the Bellman-Ford algorithm.</answer>
        </question>
        <!-- TODO: If acyclic (a DAG), it can be linear with topological sort. Page 491 of TADM. -->

        <question id="algorithm-for-all-pairs-shortest-path">
            <text>All Pairs Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem#All-pairs_shortest_paths</link>
            <answer>Floyd-Warshall, Johnson's, or repeated Dijkstra's algorithm.</answer>
        </question>

        <question id="algorithm-for-transitive-closure">
            <text>Transitive Closure</text>
            <link>https://en.wikipedia.org/wiki/Transitive_reduction</link>
            <answer>BFS or DFS, or modify Floyd-Warshall's algorithm to calculate only reachability.</answer>
        </question>

        <question id="algorithm-for-bipartite-matching-unweighted">
            <text>Bipartite Matching (unweighted)</text>
            <link>https://en.wikipedia.org/wiki/Matching_%28graph_theory%29#In_unweighted_bipartite_graphs</link>
            <answer>A Maximum Flow algorithm after adding source and sink vertices and setting all edge capacities to 1.</answer>
        </question>

        <question id="algorithm-for-bipartite-matching-weighted">
            <text>Bipartite Matching (weighted)</text>
            <link>https://en.wikipedia.org/wiki/Matching_%28graph_theory%29#In_weighted_bipartite_graphs</link>
            <answer>Hungarian Algorithm.</answer>
        </question>

        <!-- TODO?
         question id="algorithm-for-matching">
            <text>Graph Matching</text>
            <link>https://en.wikipedia.org/wiki/Matching_%28graph_theory%29</link>
            <answer>.</answer>
        </question>
        -->

        <question id="algorithm-for-maximum-flow">
            <text>Maximum Flow</text>
            <link>https://en.wikipedia.org/wiki/Maximum_flow_problem</link>
            <answer>Edmonds-Karp (Ford-Fulkerson), Dinic's, or Push-Relabel.</answer>
        </question>



    </section>

</quiz>
